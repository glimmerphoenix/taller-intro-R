[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Taller de Introducción a R",
    "section": "",
    "text": "Introducción\nBienvenidos al Taller de Introducción a R para estudiantes del Programa de Doctorado en Ciencias Agrarias y Ambientales de la UCLM.\nEn este taller se introducen los elementos básicos para programar con el lenguaje R. Este es un lenguaje de programación científica, creado originalmente para aplicaciones matemáticas y estadísticas y que está disponible como software libre, bajo licencia GNU GPL 3.\nPor otra parte, este no es un taller de introducción a la programación. Si no estás familiarizado con conceptos básicos como variables, sentencias o comandos, control de flujo de ejecución, funciones, etc. podrás seguir los contenidos desde un punto de vista práctico, pero muy probablemente no comprendas del todo bien cómo funcionan los ejemplos que se muestran. En este caso, te recomendamos que te familiarices primero con los conceptos básicos de programación antes repasar estos contenidos. Puedes consultar el capítulo 11  Recursos adicionales para encontrar referencias que te ayuden a aprender conceptos básicos de programación.\nEste es un taller práctico, que presenta numerosos ejemplos de comandos y código ejecutable para aprender a programar con el lenguaje R. Nuestro objetivo no es realizar una presentación exhaustiva de todas las posibilidades que ofrece R, sino solo los elementos básicos para adquirir destreza a nivel elemental. A partir de aquí, deberías ser capaz de seguir aprendiendo sobre aspectos del lenguaje R y las opciones que ofrecen multitud de paquetes de expansión de funcionalidad publicados en el repositorio CRAN (consulta la sección 1.5 Paquetes R).\nEste manual que acompaña al Taller de Introducción a R ha sido elaborado con Quarto (https://quarto.org), una herramienta de creación de documentación científica compatible, entre otros lenguajes, con R. Para aprender más detalles sobre Quarto puedes visitar la completa guía disponible en https://quarto.org/docs/guide/. En concreto, la creación de libros como este utilizando Quarto está documentada en https://quarto.org/docs/books.",
    "crumbs": [
      "Introducción"
    ]
  },
  {
    "objectID": "index.html#licencia",
    "href": "index.html#licencia",
    "title": "Taller de Introducción a R",
    "section": "Licencia",
    "text": "Licencia\nA menos que explícitamente se indque lo contrario, los materiales proporcionados en este taller se publican bajo una licencia Creative Commons Atribución-Compartir-Igual (CC-BY-SA) versión 4.0. Se puede acceder a los términos legales y el texto completo de esta licencia mediante este enlace.",
    "crumbs": [
      "Introducción"
    ]
  },
  {
    "objectID": "01-Rlang.html",
    "href": "01-Rlang.html",
    "title": "1  El lenguaje R",
    "section": "",
    "text": "1.1 ¿Qué es R?\nR es un lenguje de programación especialmente pensado para el análisis y la visualización de datos. Fue creado por Ross Ihaka y Robert Gentleman como una versión libre del lenguaje estadístico S, creado en Bell Labs. Su uso está ampliamente extendido en investigación, docencia e industria. Empresas como Google, Facebook, Twitter, NYT, Pfizer, Santander, BBVA y Teléfonica, entre otras, utilizan este lenguje en sus desarrollos. Entre otras características, R cuenta con: - Capacidad para el almacenamiento y manipulación efectiva de datos. - Operadores para realizar cálculos sobre variables indexadas (Arrays), en particular matrices. - Una amplia colección de herramientas para el análisis de datos. - Multitud de opciones para el análisis gráfico de datos. - Como cualquier otro lenguaje de programación, también incluye sentencias condicionales, ciclos, funciones recursivas y posibilidad de entradas y salidas.",
    "crumbs": [
      "Instalación y conceptos básicos",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>El lenguaje R</span>"
    ]
  },
  {
    "objectID": "01-Rlang.html#rstudio",
    "href": "01-Rlang.html#rstudio",
    "title": "1  El lenguaje R",
    "section": "1.2 RStudio",
    "text": "1.2 RStudio\nRStudio es un entorno de programación con R creado por la compañía norteamericana Posit PBC. Este entorno de desarrollo cuenta con un interprete de R que evalua expresiones aritméticas, lógicas y llamadas a funciones o asignaciones. Algunas de estas expresiones (siempre y cuando sean correctas) pueden producir una salida visible que se puede almacenar en alguna variable, en disco o en un fichero. También es posible leer y escribir ficheros de datos, así como generar y guardar gráficos, crear scripts (archivos con listados de comandos ejecutables escritos en R) o crear ficheros de informes.",
    "crumbs": [
      "Instalación y conceptos básicos",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>El lenguaje R</span>"
    ]
  },
  {
    "objectID": "01-Rlang.html#cómo-se-mantiene-r-en-la-actualidad",
    "href": "01-Rlang.html#cómo-se-mantiene-r-en-la-actualidad",
    "title": "1  El lenguaje R",
    "section": "1.3 ¿Cómo se mantiene R en la actualidad?",
    "text": "1.3 ¿Cómo se mantiene R en la actualidad?\nPor un lado está la R Foundation, una fundación sin ánimo de lucro que gestiona IPR. Por otro lado tenemos RCore Team, un grupo de personas con privilegios para cambiar el codigo base de R. Adicionalmente están los R Contributors, numerosos desarrolladores que han realizado diversas aportaciones al proyecto.\nR Consortium: https://www.r-consortium.org.\nComunidad R Hispano (http://r-es.org): Organiza jornadas anuales (conferencias, talleres…). Grupos locales, meetups (http://madrid.r-es.org)",
    "crumbs": [
      "Instalación y conceptos básicos",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>El lenguaje R</span>"
    ]
  },
  {
    "objectID": "01-Rlang.html#ventajas-e-inconvenientes-de-r.",
    "href": "01-Rlang.html#ventajas-e-inconvenientes-de-r.",
    "title": "1  El lenguaje R",
    "section": "1.4 Ventajas e inconvenientes de R.",
    "text": "1.4 Ventajas e inconvenientes de R.\nDentro de las ventajas de R podemos destacar las siguientes: - Se trata de una herramienta de software libre, gratuito. - La comunidad que le da soporte es una comunidad sólida, con múltiples participantes del mundo académico y de la industria. - Es posible obtener soporte comercial mediante proveedores. - Ya ha conseguio suficiente masa crítica. - Podemos adaptarlo y personalizarlo mediante el desarrollo de funciones, paquetes o plantillas de documentos. - Casi cualquier innovación en estadística ya está implementada en R. - Facilita la creación y autorimatización de flujos de trabajo y análisis reproducibles, utilizando herramientas adicionales como Quarto.\nA pesar de todas sus bondades, podemos encontrar algunos inconvenientes: - Hay que aprender a programar (aunque solo sea un poco). - Para aquellos que saben programar en otros lenguajes, sobre todo siguiendo el paradigma de orientación a objetos, el lenguaje R no resulta intuitivo, es decir, presenta una cierta curva de aprendizaje. - Existen interfaces gráficas, pero es importante acostumbrarse a revisar el código fuente y la salida. Solo así comprendemos qué hace realemnte el método o algoritmo que estamos aplicando.",
    "crumbs": [
      "Instalación y conceptos básicos",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>El lenguaje R</span>"
    ]
  },
  {
    "objectID": "01-Rlang.html#sec-r-packages",
    "href": "01-Rlang.html#sec-r-packages",
    "title": "1  El lenguaje R",
    "section": "1.5 Paquetes R",
    "text": "1.5 Paquetes R\nUna de las características más potentes de R es la disponibilidad de una enorme cantidad de paquetes que amplían su funcionalidad. Podemos ver los paquetes R como módulos que podemos conectar dinamicamente a nuestros programas para disponer de inmediato de un nuevo catálogo de funciones y elementos para realizar diversar tareas: trabajar con nuevos tipos de modelos estadísticos o de aprendizaje automático, lectura y escritura de datos, preparación y limpieza de datos, etc.\nEn la página web https://cran.r-project.org/, si pulsamos en el enlace Packages en el menú lateral izquierdo se mostrará una página que resume información sobre los paquetes R disponibles para ampliar la funcionalidad de nuestros programas. En este momento, existen más de 21.400 paquetes publicados, lo que da una idea del vasto catálogo de herramientas que la comunidad R pone a nuestra disposición.\nUna ventaja que conviene resaltar es que muchos de estos paquetes han sido desarrollados por destacados/as cientficos/as y profesionales de diferentes ámbitos (Matemáticas, Estadística, Ciencias de la Computación), así como de numerosas áreas de aplicación, entre ellas las Ciencias Agrarias y Medioambientales. Para cada paquete, existe una página de descripción en la que podemos consultar los datos sobre las personas que lo han creado y las encargadas de mantenerlo.\nPara poder utilizar un paquete primero debemos instalarlo (sólo una vez), mediante el comando install.packages(\"nombre-del-paquete\"). Por ejemplo, para instalar el paquete dplyr ejecutamos:\n\ninstall.packages(\"dplyr\")\n\nUna vez que el paquete se instala sin errores, a partir de ese momento podemos ya cargarlo directamente en cualquier script o programa de R mediante el comando library:\n\nlibrary(dplyr)\n\nDespués de ejecutar el comando, todas las funciones y resto de elementos (como conjuntos de datos) contenidos en el paquete pasan a estar disponibles para ser utilizados en nuestros programas.\n\n\n\n\n\n\nOrden de carga de los paquetes\n\n\n\nDebemos ser cuidadosos al decidir en qué orden vamos a cargar paquetes adicionales en nuestro script o programa de R. Algunso paquetes pueden tener elementos (funciones, objetos, datasets, etc.) cuyo nombre coincida con el de otro elemento previamente cargado en un paquete anterior.\nEn estos casos de coincidencia de nombres, ocurre que el último elemento cargado sobrescribe a otro del mismo nombre cargado desde un paquete anterior. En estos casos, podemos fijarnos en que el intérprete de R nos avisará mediante mensajes de qué elementos han sustituido a otros con el mismo identificador cargados con anterioridad.\nUna solución para indicar exactamente qué elemento queremos invocar y a qué paquete pertenece es utilizar la sintaxis paquete::funcion().",
    "crumbs": [
      "Instalación y conceptos básicos",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>El lenguaje R</span>"
    ]
  },
  {
    "objectID": "01-Rlang.html#fuentes-de-información-sobre-r",
    "href": "01-Rlang.html#fuentes-de-información-sobre-r",
    "title": "1  El lenguaje R",
    "section": "1.6 Fuentes de información sobre R",
    "text": "1.6 Fuentes de información sobre R\n\nCuenta de Posit PBC en Instagram.\nCanal Posit PBC en Youtube.\nGrupos locales de usuarios R.\nMeetups sobre R.",
    "crumbs": [
      "Instalación y conceptos básicos",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>El lenguaje R</span>"
    ]
  },
  {
    "objectID": "02-install.html",
    "href": "02-install.html",
    "title": "2  Instalación de R y R Studio",
    "section": "",
    "text": "2.1 Trabajando con RStudio\nLa pantalla principal de RStudio se divide en cuatro áreas o paneles, cuya posición y tamaño podemos modificar:\nEl panel superior izquierdo es el editor de código, donde se escriben los programas. Nuestro código podemos escribirlo en scripts, con el fin de poder utilizarlos en otros proyectos. En estos scripts se realiza un diagnóstioc de sintaxis con el siguiente código de colores: una cruz roja indica que hay un error de sintaxis, una exclamación amarilla indica que la variable o el objeto no se utiliza o que no se ha declarado, y un círculo azul nos ofrece la opción de solicitar información de ayuda sobre lo que estamos haciendo.\nJusto debajo del editor de código se encuentra el panel de la consola, que es la parte principal de RStudio. Se trata de un intérprete interactivo de comandos en el que podemos escribir líneas de código. Las líneas de código pueden ser:\nSi la sentencia produce una salida, al darle a intro esta salida se visualizará justo debajo de la línea de código y se habilitará la siguiente línea para introducir la siguiente instrucción, tal y como se observa en la siguiente figura.\nComo usuarios principiantes de R, podemos ver la consola como el espacio en el que vamos a teclear todas nuestras líneas de código. Sin embargo, conforme vayamos aconstumbrándonos al lenguaje y al entorno, nuestras líneas de código pasarán a estar en scripts que podremos abrir, ejecutar y modificar, tantas veces como queramos.\nEn la parte superior derecha está el panel de programación donde aparecen utilidades como el lisado de las variables de entorno, el historial de comandos previamente ejecutados, acceso a herramientas para control de versiones de código o conexiones a fuentes externas de datos (bases de datos, etc.). En la pestaña de Enviroment por cada objeto que creemos en nuestro código, su contenido lo podemos ver aquí de forma automática. Se pueden guardar los objetos del espacio de trabajo en un fichero con extensión .RData. También es posible recuperar los objetos creados en alguna sesión anterior sin más que cargar el correspondiente fichero con extensión .Rdata. Además, es posible limpiar los objetos que hay en el espacio de trabajo. Al conjunto de objetos que tengamos almacenados en cada momento se denomina espacio de trabajo (workspace).\nUna opción muy importe es la poder importar un Dataset. Después de elegir el formato en el que se encuentra el Dataset y su localización (ruta), en la ventana de código se abrirá una nueva pestaña en la que podremos ver el contenido del Dataset.\nLa pestaña History muestra el historial de todos los comandos introducidos. Toda instrucción que escribamos en la línea de comandos se carga aquí automáticamente. Se puede guardar el contenido de esta ventana en un fichero, con extensión .Rhistory. Por lo que, también podremos cargar (abrir) un fichero de históricos. Nos ofrece la posibilidad de poder recuperar las instrucciones y pasarlas a la consola o al script que tengamos abierto. Mediante el icono de la escoba, podremos borrar todo el histórico de instrucciones.\nPor último, en la parte inferior derecha se encuentra el panel multifunción, donde está el navegador de archivos, el carrusel de gráficas, el gestor de paquetes, la ayuda en línea y el visualizador. En este panel podremos realizar diversas actividades: - Mediante la pestaña Files podemos explorar archivos en nuestro ordenador. - En la pestaña Plots irán apareciendo los diversos gráficos que vayamos construyendo. Podremos navegar a través de todas las representaciones que hayamos hechos, podremos aplicar zoom en ellas, exportarlas en diferentes formatos. También podremos eliminar individualmente las representaciones que tengamos o, incluso, eliminarlas todas. - En Packages podremos ver todos los paquetes que tenemos instalados en RStudio. Mediante el icono install podremos instalar nuevos paquetes, sin más que seleccionar el repositorio, tecleando el nombre del paquete e indicando la ruta donde se va a instalar. También se pueden actualizar los paquetes instalados y eliminar los que ya no nos interesen.\nA continuación ofrecemos un resumen de comandos rápidos para trabajar en RStudio.",
    "crumbs": [
      "Instalación y conceptos básicos",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Instalación de R y R Studio</span>"
    ]
  },
  {
    "objectID": "02-install.html#trabajando-con-rstudio",
    "href": "02-install.html#trabajando-con-rstudio",
    "title": "2  Instalación de R y R Studio",
    "section": "",
    "text": "Figura 2.1: Interfaz gráfica de RStudio.\n\n\n\n\n\n\nÓrdenes elementales (instrucciones) como una expresión o una asignación. Una expresión se evalúa, se imprime su valor y se pierde, es decir, no se puede utilizar posteriormente. Sin embargo, en una asignación, se evalúa la expresión, no se imprime el valor y éste se guarda en una variable, para poder ser utilizado posteriormente.\nSolicitudes de ayuda, por ejemplo: help(solve) o, de forma alternativa, ?solve.\nLlamadas a funciones.\nInstrucciones que generen gráficas.\n\n\n\n\n\n\n\n\nFigura 2.2: Línea de código en la consola.\n\n\n\n\n\n\n\n\n\n\n\nFigura 2.3: Environment.\n\n\n\n\n\n\n\n\n\n\n\nFigura 2.4: History.\n\n\n\n\n\n\n\n\n\n\nFigura 2.5: Packages e instalación de paquetes.\n\n\n\n\nCuando se ejecute una instrucción que solicite ayuda sobre un determinado comando, esta ayuda se visualizará en la pestaña Help. También nos permite navegar a través de todos los topics de ayuda que hayamos realizado, así como poder imprimirlos. Incluso, es posible realizar una búsqueda de ayuda general. Para cualquier documento que estemos consultando, tiene un buscador para buscar dentro de él.\n\n\n\n\n\n\n\nFigura 2.6: Help.\n\n\n\n\n\n\n\n\n\n\nFigura 2.7: Comandos rápidos.",
    "crumbs": [
      "Instalación y conceptos básicos",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Instalación de R y R Studio</span>"
    ]
  },
  {
    "objectID": "02-install.html#sec-projects",
    "href": "02-install.html#sec-projects",
    "title": "2  Instalación de R y R Studio",
    "section": "2.2 Proyectos de RStudio y directorio de trabajo",
    "text": "2.2 Proyectos de RStudio y directorio de trabajo\nLos diferentes proyectos que vayamos haciendo los iremos guardando en diferentes directorios, esto es, en diferentes carpetas. En cada uno de estos directorios estarán localizados el conjunto de scripts y de paquetes que se usan en ese proyecto, los datos de entrada y los resultados analíticos y representaciones que hayamos hecho. A esto se le llama directorio de trabajo. En el menú Session tenemos la opción de establecer un determinado directorio como directorio de trabajo:\n\n\n\n\n\n\nFigura 2.8: Selección del directorio de trabajo.\n\n\n\nVeamos, mediante un sencillo ejemplo, como se trabaja con proyectos en RStudio. Lo primero es crear el proyecto, en el menú File tenemos la opción New Porject:\n\n\n\n\n\n\nFigura 2.9: Paso 1: ventana New Project.\n\n\n\nHaciendo click en New Directory, llegaremos a la siguiente ventana donde debemos seleccionar la opción New Project:\n\n\n\n\n\n\nFigura 2.10: Paso 2: ventana New Directory.\n\n\n\nFinalmente indicamos el nombre que queremos darle a nuestro proyecto, por ejemplo: Poryecto1. Haciendo click en Create Project ya tendremos nuestro primer proyecto creado.\n\n\n\n\n\n\nFigura 2.11: Paso 3: nombre del proyecto.\n\n\n\nAhora estamos en disposición de poder introducir nuestras líneas de código. Para ello, copiaremos las siguientes instrucciones en la consola. Conforme vayamos introduciendo las líneas de código, en la pestaña Environment irán apareciendo cada uno de los objetos que vamos creando junto con sus valores. Cuando introduzcamos las intrucciones que generan una representación gráfica, ésta aparecerá en la pestaña Plots.\n\n\n\n\n\n\nFigura 2.12: Paso 4: cógido del proyecto.\n\n\n\nSi en la pestaña History pulsamos el icono Guardar y salvamos el código en un fichero con extensión .R (es decir, en un script), cuando volvamos abrir Rstudio podremos abrir el código de nuestro proyecto y modificarlo tantas veces como queramos. Más adelante (en otro taller) abordaremos alternativas más avanzadas para generar documentos que combinen contenido textual formateado con bloques de código ejecutable R, que pueden generar también resultados (numéricos, gráficos, tablas) que se integran directamente en el documento.\n\n\n\n\n\n\nFigura 2.13: Abrir el proyecto.\n\n\n\nLa creación de proyectos nos facilita el trabajo en RStudio, ya que nos permite tener juntos todos los ficheros de código, almacenar el histórico de comandos y guardar las variables de entorno, tal y como las dejamos al cerrar la sesión.",
    "crumbs": [
      "Instalación y conceptos básicos",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Instalación de R y R Studio</span>"
    ]
  },
  {
    "objectID": "03-workflow.html",
    "href": "03-workflow.html",
    "title": "3  Organización de proyectos",
    "section": "",
    "text": "3.1 Estructura de directorios\nAdemás de crear un proyecto, resulta conveniente seguir un esquema consistente para la creación de carpetas dentro del directorio principal de nuestro proyecto. De este modo, todo estará siempre bien organizado y cuando acudamos a un proyecto que se creó hace tiempo nos resultará más sencillo encontrar rápidamente los recursos que buscamos.\nNo se puede dar una fórmula general para un listado de carpetas válido para cualquier proyecto, pero si se pueden sugerir carpetas que suelen ser útiles. Cada programador o equipo debe decidir, en función del tipo de proyectos, los recursos a gestionar y sus objetivos, qué combinación de carpetas es más adecuada en cada caso.",
    "crumbs": [
      "Instalación y conceptos básicos",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Organización de proyectos</span>"
    ]
  },
  {
    "objectID": "03-workflow.html#estructura-de-directorios",
    "href": "03-workflow.html#estructura-de-directorios",
    "title": "3  Organización de proyectos",
    "section": "",
    "text": "data: directorio para almacenar los archivos de datos disponibles. Por ejemplo, datos que hemos descargado previamente o que se descargarán periodicamente de forma automatizada mediante herramientas o scripts, datos generados por nuestros programas, etc.\n R o r: carpeta para guardar nuestros scripts. Incluso en el caso en que sólo tengamos un script en nuestro proyecto, es recomendable crearla porque es muy probable que el proyecto crezca y terminemos creando más (se debe evitar a toda costa crear scripts “kilométricos”).\n doc: para documentación de nuestro proyecto, ejemplos de uso, etc. En el caso de que usemos una herramienta de documentación específica habrá que leer su manual de uso para seguir exactamente la estructura que necesite.\n deliverables o inform: para contener informes o documentos de resumen creados con Quarto o RMarkdown con extractos y resúmenes de resultados.\n slides o diapos: si tenemos que preparar presentaciones con diapositivas puede ser una buena idea organizarlas en su propio directorio independiente.\n img: si nuestro proyecto emplea imágenes (mapas, tomas satelitales, fotografías, etc.) es una buena idea organizarlas todas dentro de una misma carpeta, aparte del resto de datos.\n test: puede ser útil para almacenar scripts de prueba que todavía no son del todo correctos o no están probados a fondo. También para incluir pruebas formales de corrección de nuestros scripts (comprobación de robustez).\n tmp: para almacenar archivos de datos intermedios o ficheros efímeros, que no pretendemos conservar más que para unas pocas ejecuciones (pruebas, etc.).\n log: si nuestro proyecto involucra una gran cantidad de operaciones que pueden consumir mucho tiempo de ejecución, es conveniente que se generen ficheros de registro o logs del progreso de dichas operaciones.\n util o utils: conserva scripts que suelen contener funciones y otras herramientas de utilidad que se emplean para realizar operaciones básicas en los scripts principales del directorio R. De esta forma, se modulariza el código, separándolo en ficheros diferentes para gestionarlo y mantenerlo mejor (recordemos que hay que evitar meter todo en un solo archivo enorme).\n aux, notas, utils, labs, practicas, ejercicios, etc.: posibles directorios que pueden surgir en fución del tipo de proyecto que abordemos (prácticas de un curso, experimentos, laboratorios y otros).",
    "crumbs": [
      "Instalación y conceptos básicos",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Organización de proyectos</span>"
    ]
  },
  {
    "objectID": "03-workflow.html#tipos-de-proyectos",
    "href": "03-workflow.html#tipos-de-proyectos",
    "title": "3  Organización de proyectos",
    "section": "3.2 Tipos de proyectos",
    "text": "3.2 Tipos de proyectos\n\nProyecto estándar de análisis de datos: Suele constar de un directorio de datos, scripts y/o documentos científicos para procesamiento y análisis de datos y funciones de utilidad.\nPaquete R: Tienen una estructura de directorios, archivos de código y documentación bien definida. Se deben seguir las reglas de organización, especialmente si pretendemos publicarlo en un repositorio oficial como CRAN. Se pueden consultar referencias como https://r-pkgs.org/structure.html para aprender más sobre la estructura interna de los paquetes de R.\nSitio web: Se pueden crear sitios web de diversa índole como, por ejemplo, sitios personales para presentar nuestro CV, trayectoria y trabajos más relevantes; sitio web de una organización, blogs, etc. Herramientas como Quarto facilitan enormemente esta tarea (véase https://quarto.org/docs/websites/).\nLibros/documentos científicos: Herramientas complementarias como los paquetes rmarkdown, bookdowny, más recientemente, Quarto (véase https://quarto.org/docs/authoring/markdown-basics.html), nos permiten crear documentos científicos o compendios (libros) de manera fácil y muy potente, con multitud de opciones de configuración y ajustes estéticos y funcionales.\nPresentación con diapositivas: Nuevamente, herramientas como Quarto permiten realizar presentaciones de forma directa y versátil (véase https://quarto.org/docs/presentations/).\nDashboards: Uno de los tipos de proyectos más populares consiste en la creación de un dashboard o panel de seguimiento para mostrar dinámicamente datos, modelos y tendencias de evolución. También permite generar herramientas interactivas para presentación de conceptos, docencia, etc. La herramienta Shiny (https://shiny.posit.co/) destaca sobremanera en este apartado.",
    "crumbs": [
      "Instalación y conceptos básicos",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Organización de proyectos</span>"
    ]
  },
  {
    "objectID": "04-Rbase.html",
    "href": "04-Rbase.html",
    "title": "4  Programación básica en R",
    "section": "",
    "text": "4.1 Objetos y variables.\nEn este apartado se ofrece un breve repaso a la sintáxis básica de R.\nLos objetos o variables de R pueden almacenar información de diferentes tipos:\nCuando se crea una variable, la asingación de un valor a esta variable puede hacerse de la siguiente manera:\nvat1 &lt;- 1.2\nvat1\n\n[1] 1.2\n\nvat2 = 0.25\nvat2\n\n[1] 0.25\nEn este ejemplo puede verse como se han creado dos variables de tipo numérico utilizando dos símbolos diferentes para realizar la asignación.\nCualquier variable solo puede tener un único valor en cada instante de tiempo. De modo que si se asigna un nuevo valor a una variable, estamos eliminando el valor que habíamos almacenado antes.\ny = 93\ny\n\n[1] 93\n\ny = 52\ny\n\n[1] 52\nLa asignación también se puede hacer mediante una expresión. Esta expresión se evaluará y el valor obtenido se asigna al objeto:\nz = 3\nw = z^2\nw\n\n[1] 9\n\ni = (z*2+75)/2\ni\n\n[1] 40.5\nPor lo tanto, la asingación es una operación en la que se evalua la expresión que hay a la derecha y se le asigna ese valor a la variable de la izquierda.",
    "crumbs": [
      "El lenguaje R",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Programación básica en R</span>"
    ]
  },
  {
    "objectID": "04-Rbase.html#objetos-y-variables.",
    "href": "04-Rbase.html#objetos-y-variables.",
    "title": "4  Programación básica en R",
    "section": "",
    "text": "valores numéricos en variables de tipo numérico;\nvalores alfabéticos en variables de tipo carácter, que en realidad son cadenas de caracteres que van entre comillas dobles o comillas simples;\nvalores lógicos en variables de tipo booleano, que solo pueden tomar los valores TRUE o FALSE.\n\n\n\n\n\n\n\n\n\n\n4.1.1 Función ls().\nMuestra una lista de todos los objetos o variables que se han creado.\n\n\n4.1.2 Función rm().\nLibera el espacio de memoria que ocupa el objeto o variable que hayamos indicado entre paréntesis.\n\n\n4.1.3 Operadores aritméticos.\nLos operadores aritméticos elementales son los habituales +, -, *, / y ^ para elevar a una potencia. Además están disponibles las funciones log, exp, sin, cos, tan y sqrt.\n\n\n4.1.4 Operadores lógicos.\nLos operadores lógicos son: &lt; (menor), &lt;= (menor o igual), &gt; (mayor), &gt;= (mayor o igual), == (igualdad lógica), y != (distinto). Si v1 y v2 son dos expresiones lógicas, entonces v1&v2 es su intersección (“conjunción”), v1|v2 es su unión (“disyunción”) y !v1 es la negación de v1.",
    "crumbs": [
      "El lenguaje R",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Programación básica en R</span>"
    ]
  },
  {
    "objectID": "04-Rbase.html#funciones.",
    "href": "04-Rbase.html#funciones.",
    "title": "4  Programación básica en R",
    "section": "4.2 Funciones.",
    "text": "4.2 Funciones.\nLas funciones en R son un tipo especial de objeto diseñado para llevar a cabo alguna operación. Se aplican a un conjunto de argumentos y producen un resulado.\nR tiene una amplia variedad de funciones que el usuario puede utilizar. Pero también puede crearse las suyas propias. En el caso de querer utilizar una función R, no hay más que llamarla escribiendo su nombre y su lista de argumentos (en caso de tenerlos). La lista de argumentos siempre va entre paréntesis y separados por comas.\n\n# Esta instrucción devuelve el máximo de todos los números que se le han pasado por argumento\nmax(4,5,6,12,-4)\n\n[1] 12\n\n# Máximo de una secuencia de 30 elementos elegidos al azar de entre el 1 y el 100.\nmax(sample(1:100, 30))\n\n[1] 98\n\n\nAl igual que en otros lenguajes de programación, resulta interesante implementar una función cuando necesitas que varias líneas de código se ejecuten varias veces en diferentes puntos de nuestro código. En este caso, ese bloque de código lo encampsulamos dentro de una función, la cual llamaremos cada vez que la necesitemos. Antes de darle un nombre a una función que implementemos nosotros, podemos comprobar si ese nombre no se ha utilizado ya, mediante la función exists() (devuelve TRUE o FALSE en función de si el nombre de la función ya existe o no, respectivamente).\nLa forma de implementar una función es la siguiente:\n\nnombreFuncion = *fuction*(argumento1, argumento2,...){\n   instrucción1\n   instrucción2\n   .\n   .\n   .\n   return resultado\n}\n\nEl cuerpo de la función está delimitado por {} y cada instrucción debe ocupar una línea.\n\n# Función que calcula el error estandar (raiz cuadrada de la varianza entre el tamaño de la muestra)\nse = function(x){\n  v = var(x)\n  # var(): función de R que devuelve la varianza de un conjunto de valores, en este caso, de x\n  n = length(x)\n  # length(): función de R que devuelve el número de valores en x\n  return(sqrt(v/n))\n  # sqrt(): función de R que devuelve la raiz cuadrada\n}\n\nUna vez que hemos creado la función, podemos usarla:\n\n# rnorm(): función de R que devuelve una muestra de 100 números aleatorios tomados una distribución normal con media=20 y desviación estandar=4.\nmySample = rnorm(100, mean=20, sd=4)\nse(mySample)\n\n[1] 0.388467\n\n\n\n4.2.1 Parámetros con valores por defecto.\nSi alguno de los parámetros de nuestra función tiene que tomar algún valor por defecto debemos indicarlo en la cabecera de la función.\n\n#Función que convierte un valor en km, decímetros, centímetros o milímetros a metros.\nconvUnitsToMeters = function(val, from=\"km\"){\n  #La función switch de R compara el contenido de una variable (en este caso \"to\") con\n  #un conjunto de opciones. En el caso de que la variable indicada no se corresponda con\n  #ninguna de las opciones posibles, se retornará el valor especial NA\n  mult = switch(from,km=1000,dm=0.1,cm=0.01,mm=0.001,NA)\n  if (is.na(mult)) stop(\"Unknown target unit of lenght\")\n  else return (val*mult)\n}\n#Si se llama a la función con dos parámetros, el valor por defecto se sustituye\n#por el valor indicado por el usuario\nconvUnitsToMeters(23,\"km\")\n\n[1] 23000\n\nconvUnitsToMeters(40,\"cm\")\n\n[1] 0.4\n\n#Si solo se pasa un parámetro, el segundo toma el valor por defecto\nconvUnitsToMeters(40)\n\n[1] 40000\n\n\n\n\n4.2.2 Llamada a una función.\nLa llamada a una función se puede realizar de dos formas:\n\nIndicando el nombre de los parámetros. En este caso el valor que toma cada parámetro es el indicado.La ventana que ofrece el llamar a una función indicando el nombre de los parámetros, es que podemos omitir el nombre de parámetros que tengan valor por defecto y no queramos modificar ese valor e indicar solo aquel parámetro o parámetros que si queramos modificar.\n\n\nconvUnitsToMeters(from=\"km\",val=56.2)\n\n[1] 56200\n\n\n\nSin indicar el nombre de los parámetros. En este caso el valor de los parámetros se susittye por posición. En el ejemplo que se muestra a continuación, el primer argumento toma el valor 56.2 y el segundo toma el valor \"yard\".\n\n\nconvUnitsToMeters(56.2,\"km\")\n\n[1] 56200\n\n\nTambién es posible mezclar ambas formas de llamar a una función:\n\nconvUnitsToMeters(56.2, from=\"km\")\n\n[1] 56200",
    "crumbs": [
      "El lenguaje R",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Programación básica en R</span>"
    ]
  },
  {
    "objectID": "05-data-types.html",
    "href": "05-data-types.html",
    "title": "5  Tipos de datos",
    "section": "",
    "text": "5.1 Vectores.\nEs el objeto básico de R. Incluso cuando estamos asignando un valor a una variable, en realidad lo que estamos haciendo es un vector de un solo elemento. Como en cualquier otro lenguaje de programación, un vector es una estructura en la que podemos almacenar valores del mismo tipo (numéricos, valores lógicos o cadenas de caracteres), es decir, es una estructura de datos homogénea en la que los valores almacenados ocupan una determinada posición.",
    "crumbs": [
      "El lenguaje R",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Tipos de datos</span>"
    ]
  },
  {
    "objectID": "05-data-types.html#vectores.",
    "href": "05-data-types.html#vectores.",
    "title": "5  Tipos de datos",
    "section": "",
    "text": "5.1.1 Creacción de vectores.\nExisten varias formas de definir un vector:\n\nMediante el operador :. Es una forma sencilla de generar secuencias de valores. Este operador tiene la máxima prioridad en una expresión.\n\n\nv = 1:10\nv\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\n# Hay que tener cuidado con la precedencia del operador :\n10:15 - 1\n\n[1]  9 10 11 12 13 14\n\n10:(15 - 1)\n\n[1] 10 11 12 13 14\n\n# Secuencia decreciente\n5:0\n\n[1] 5 4 3 2 1 0\n\n\n\nUna forma fácil de crear un vector en R es mediante la función c(), a la que se le indica entre paréntesis los elementos que va contener el vector. El número de elementos de un vector es su tamaño y podemos obtenerlo mediante la función length().\n\n\nv = c(5, 2, 53.85, 43.2, 30)\nv\n\n[1]  5.00  2.00 53.85 43.20 30.00\n\nlength(v)\n\n[1] 5\n\nmode(v)  #Indica el tipo de datos que almacena el vector.\n\n[1] \"numeric\"\n\nv = c(5, 2, 53.85, 43.2, 30, \"abc\")\n#Todos los elementos del vector se han convertido a tipo string (lo comprobamos).\nv\n\n[1] \"5\"     \"2\"     \"53.85\" \"43.2\"  \"30\"    \"abc\"  \n\nmode(v)\n\n[1] \"character\"\n\n\n\nY mediante la función seq(). Esta función tiene cinco argumentos, aunque no se utilizan todos simultáneamente. Si se dan los dos primeros indican el comienzo y el final del vector. Si solo se facilitan estos dos argumentos, el resultado coincide con el operador ‘dos puntos’.\n\n\nx = seq(-3, 3, by=.5) #inicio, fin, salto\nx\n\n [1] -3.0 -2.5 -2.0 -1.5 -1.0 -0.5  0.0  0.5  1.0  1.5  2.0  2.5  3.0\n\n# Al especificar que solo queremos 4 elementos, calcula él el salto\nseq(from = 1, to = 5, length = 4) \n\n[1] 1.000000 2.333333 3.666667 5.000000\n\n# Ahora le especificamos el tamaño, el inicio y el salto, por lo que calcula automáticamente\n# cual será el fin\nseq(length = 10, from = -2, by = 0.2)\n\n [1] -2.0 -1.8 -1.6 -1.4 -1.2 -1.0 -0.8 -0.6 -0.4 -0.2\n\n\n\nOtra forma frecuente de generar secuencias es mediante la función rep():ç\n\n\nrep(5, 4)\n\n[1] 5 5 5 5\n\nrep(1:2, 3)\n\n[1] 1 2 1 2 1 2\n\nrep(1:2, each = 3)\n\n[1] 1 1 1 2 2 2\n\n\n\nR también tiene diversas funciones parar generar secuencias aleatorias. Todas ellas siguen esta estructura: rfunc(n, par1, par2, ...), donde func es el nombre de la distribución de probabilidad, n es el número de elementos que se van a generar, y par1, par2, ... son el resto de parámetros propios de cada tipo de distribución de probabilidad.\n\n\n# Distribución normal\nrnorm(10)\n\n [1] -0.7176027 -1.3956246  0.5798652  1.0484496  1.1002842  0.2002303\n [7]  0.1049599 -0.8266588  0.9600543  1.5440505\n\nrnorm(4, mean=10, sd=3)\n\n[1]  7.421695 14.617885  5.299725  8.549312\n\n# Distribución t Student\nrt(5, df=10)\n\n[1] -1.3529717 -0.6064445 -0.1749502  0.3060131  1.1442699\n\n\n\nLa función vector() nos permite crear vectores vacios.\n\n\nx = vector()\nx\n\nlogical(0)\n\n\n\n\n5.1.2 Valores faltantes.\nEn determinadas ocasiones puede que no todas las componentes de un vector sean conocidas. Cuando falta un elemento, es decir, tenemos un ‘valor faltante’, se le asigna un valor especial: NA. En general, cualquier operación donde intervenga un valor NA da por resultado NA. Este resultado es lógico, ya que la operación no se puede realizar porque los datos son incompletos. Existe la función is.na(x) que crea un vector lógico del tamaño del vector x que se le pasa por parámetro cuyos elementos valdrán TRUE, si el elemento correspondiente de x es NA, y FALSE, en caso contrario.\n\nvl = c(FALSE, TRUE, NA, TRUE, TRUE)\nvl\n\n[1] FALSE  TRUE    NA  TRUE  TRUE\n\n\nAlgunas funciones de gran utilidad al a hora de trabajar con vectores son:\n\nmin() y max() que seleccionan respectivamente el menor y el mayor valor de sus argumentos, incluso cuando el argumentos son varios vectores,\nrange() cuyo valor es el vector de longitud dos: c(min(x), max(x)),\nsum(x) que es la suma de todos los elementos de x,\nprod(x) que es el producto de todos ellos, y\nsort(x) que devuelve un vector del mismo tamaño que x con los elementos ordenados en orden creciente.\n\n\n\n5.1.3 Indexación de elementos\nSe puede acceder a un elemento en particular mediante el índice de la posición que ocupa.\n\n# Elemento que se encuentra en la 1º posición\nvl[1]\n\n[1] FALSE\n\n# Elemento que se encuentra en la 5º posición\nvl[5]\n\n[1] TRUE\n\n# OJO: en R, el acceder a una posición que NO existe no genera ningún error\nvl[7]\n\n[1] NA\n\n\nEl tamaño de un vector se puede modificar añadiendo más elementos.\n\n# x era un vector con elementos de -3.0 a 3.0 con salto de 0.5\n# Añadimos el elemento 28 en la posición 15:\nx[15] = 28\n# Como en la posición 14 no tenía nada, se ha añadido un NA, hasta llegar a la nueva posición\nx\n\n [1] NA NA NA NA NA NA NA NA NA NA NA NA NA NA 28\n\n\nPodemos seleccionar determinados valores de un vector atendiendo a una condición lógica. A esta condición o expresión lógica se la denomina máscara. También podemos ver esta opción como otra forma de construir un nuevo vector a partir de uno existente.\n\nx = c(0, -3, 4, -1, 45, 90, -5)\nx[x&gt;0]\n\n[1]  4 45 90\n\nx[x&lt;=-2 | x&gt;5]\n\n[1] -3 45 90 -5\n\nx[x&gt;40 & x&lt;100]\n\n[1] 45 90\n\n\nLa máscara también puede ser un vector de enteros, de manera que se seleccionan aquellos elementos que están en esas posiciones:\n\nx[c(4,6)]\n\n[1] -1 90\n\nx[1:3]\n\n[1]  0 -3  4\n\n\nSi los índices de las máscaras son negativos, cambia el significado de la máscara en el sentido en que lo que se está indicando son los índices que no se quieren coger.\n\nx[-1]\n\n[1] -3  4 -1 45 90 -5\n\nx[-c(4, 6)]\n\n[1]  0 -3  4 45 -5\n\nx[-(1:3)]\n\n[1] -1 45 90 -5\n\n\nComo R te permite darle nombre a los elementos de un vector, la máscara también puede estar formada por un vector de string, de manera que en ella se nombre solo a los elementos que se quieren.\n\npH = c(4, 5, 7, 7.3, 8.2, 6.3)\nnames(pH) = c(\"area1\", \"area2\", \"mud\", \"dam\", \"middle\")\npH\n\n area1  area2    mud    dam middle   &lt;NA&gt; \n   4.0    5.0    7.0    7.3    8.2    6.3 \n\npH2 = c(area1=4.5, area2=7, mud=7.3, dam=8.2, middle=6.3)\npH2[\"mud\"]\n\nmud \n7.3 \n\npH2[c(\"area1\",\"dam\")]\n\narea1   dam \n  4.5   8.2 \n\n\n\n\n5.1.4 Vectorización.\nUno de los aspectos más importantes de R es la vectorización de varias de sus funciones, es decir, la operación se realiza elemento a elemento. Estas funciones pueden ser aplicadas directamente a un vector generando otro vector resultado del mismo tamaño.\n\nv = c(4, 7.5, 15, 76.2, 78)\n# La función sqrt() cálcula la raiz cuadrada de su argumento. Al pasarle un vector la función \n# genera otro vector del mismo tamaño que resulta de hacer la raiz cuadrada de cada uno de sus\n# elementos.\nsqrt(v)\n\n[1] 2.000000 2.738613 3.872983 8.729261 8.831761\n\nv1 = c(1, 3, 5)\nv2 = c(18, 9, 28)\nv1+v2\n\n[1] 19 12 33\n\n2*v1\n\n[1]  2  6 10\n\n\nSi los vectores no son del mismo tamaño, R repite el vector pequeño tantas veces como sea necesario hasta rellenar todas las posiciones del grande:\n\nv1 = c(4, 6, 8, 24)\nv2 = c(10, 2)\nv1 + v2\n\n[1] 14  8 18 26\n\n# Es como si v2 fuera (10, 2, 10, 2)\n\nSi el tamaño del vector pequeño no es un múltiplo del tamaño del vector grande, sacaría un warning avisándonos de ello pero realizaría la operación rellenando el vector pequeño hasta la posición necesaria.\n\nv1 = c(4, 6, 8, 24)\nv2 = c(10, 2, 4)\nv1 + v2\n\nWarning in v1 + v2: longitud de objeto mayor no es múltiplo de la longitud de\nuno menor\n\n\n[1] 14  8 12 34",
    "crumbs": [
      "El lenguaje R",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Tipos de datos</span>"
    ]
  },
  {
    "objectID": "05-data-types.html#factores.",
    "href": "05-data-types.html#factores.",
    "title": "5  Tipos de datos",
    "section": "5.2 Factores.",
    "text": "5.2 Factores.\nLos factores son la forma que tiene R de manejar datos categóricos. Los factores tienen niveles que son los posibles valores que pueden tomar.\nVeamos un ejemplo de definición de factor a partir de un vector.\n\ncats = c(rep(\"malo\", 2), rep(\"regular\", 2), rep(\"bueno\", 3) )\n# Transformación de un vector en un factor:\nfcats = factor(cats)\nfcats\n\n[1] malo    malo    regular regular bueno   bueno   bueno  \nLevels: bueno malo regular\n\n# Código numérico para cada categoría\nas.numeric(fcats)  \n\n[1] 2 2 3 3 1 1 1\n\n# Niveles de categorías reconocidos\nlevels(fcats)  \n\n[1] \"bueno\"   \"malo\"    \"regular\"\n\n\nOtros ejemplos para ver como podemos trabajar con factores:\n\nfgenero = factor(c(\"m\", \"m\", \"m\", \"m\", \"m\"), levels = c(\"f\",\"m\"))\nfgenero\n\n[1] m m m m m\nLevels: f m\n\n# Con una variable de tipo factor podemos contar las ocurrencias de cada posible valor.\ntable(fgenero)\n\nfgenero\nf m \n0 5 \n\na = factor(c(\"adult\", \"adult\", \"juvenil\", \"juvenil\", \"adult\"))\n# Se pueden cruzar dos factores\nt = table(a,fgenero)\nt\n\n         fgenero\na         f m\n  adult   0 3\n  juvenil 0 2\n\n# Cálculo de las frecuencias marginales de cada uno de los factores\nmargin.table(t, 1)\n\na\n  adult juvenil \n      3       2 \n\nmargin.table(t, 2)\n\nfgenero\nf m \n0 5 \n\n\nLa función gl() puede utilizarse para generar secuencias a partir de factores. Esta función recibe dos paráemtros, el primer indica el número de niveles y el segundo indica el número de repeticiones de cada nivel.\n\ngl(3, 5)\n\n [1] 1 1 1 1 1 2 2 2 2 2 3 3 3 3 3\nLevels: 1 2 3\n\ngl(2, 5, labels = c(\"female\", \"male\"))\n\n [1] female female female female female male   male   male   male   male  \nLevels: female male",
    "crumbs": [
      "El lenguaje R",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Tipos de datos</span>"
    ]
  },
  {
    "objectID": "05-data-types.html#matrices-y-arrays.",
    "href": "05-data-types.html#matrices-y-arrays.",
    "title": "5  Tipos de datos",
    "section": "5.3 Matrices y Arrays.",
    "text": "5.3 Matrices y Arrays.\nLos arrays nos permiten almacenar elementos en diversas dimensiones. Las matrices son un caso especial de arrays con dos dimensiones. Tanto los arrays como las matrices en R no son más que vectores con un atributo particular que es la dimensión. Por lo tanto, también son estructuras homogéneas de almacenamiento.\n\n5.3.1 Construcción de arrays a partir de vectores.\nPor lo comentado anteriormente podemos construir un array sin más que proporcionandole al vector donde están almacenados los datos con unas dimensiones.\n\nm = c(45, 23, 66, 77, 33, 44, 56, 12, 78, 23)\nm\n\n [1] 45 23 66 77 33 44 56 12 78 23\n\n# El contenido del vector se reparte a través de la matriz con 2 filas y 5 columnas.\ndim(m) = c(2, 5)\nm\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,]   45   66   33   56   78\n[2,]   23   77   44   12   23\n\n\n\n\n5.3.2 Función matrix().\nTambién se puede definir directamente una matriz haciendo uso de la función matrix():\n\n# 1º argumento: contenido de la matriz en forma de vector\n# 2º argumento: número de filas\n# 3º argumento: número de columnas\n# De esta forma, la matriz se va rellenando por columnas\nm = matrix(c(45, 23, 66, 77, 33, 44, 56, 12, 78, 23), 2, 5)\nm\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,]   45   66   33   56   78\n[2,]   23   77   44   12   23\n\n# Si queremos que la matriz se vaya rellenando por filas, debemos utilizar el argumento byrow\nm = matrix(c(45, 23, 66, 77, 33, 44, 56, 12, 78, 23), 2, 5, byrow = TRUE)\nm\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,]   45   23   66   77   33\n[2,]   44   56   12   78   23\n\n\n\n\n5.3.3 Función array()\nPara facilitar la creacción de arrays tenemos la función array(), que funciona de un modo similar a matrix(). En el primer argumento se le indica el contenido del array y mediante el argumento dim le podemos especificar el tamaño de cada una de las dimensiones.\n\n# Array de dimensión 4x3x2\na = array(5:29, dim=c(4, 3, 2))\na\n\n, , 1\n\n     [,1] [,2] [,3]\n[1,]    5    9   13\n[2,]    6   10   14\n[3,]    7   11   15\n[4,]    8   12   16\n\n, , 2\n\n     [,1] [,2] [,3]\n[1,]   17   21   25\n[2,]   18   22   26\n[3,]   19   23   27\n[4,]   20   24   28\n\n\n\n\n5.3.4 Nombres de filas y columnas.\nEn R tenemos las funciones colnames() y rownames() que nos permiten dar nombres a las filas y a las columnas de una matriz.\n\nresults = matrix(c(10, 20, 30, 40, 21, 32, 43, 13), 2, 4, byrow = TRUE)\ncolnames(results) = c(\"1qrt\", \"2qrt\", \"3qrt\", \"4qrt\")\nrownames(results) = c(\"row1\", \"row2\")\nresults\n\n     1qrt 2qrt 3qrt 4qrt\nrow1   10   20   30   40\nrow2   21   32   43   13\n\n\n\n\n5.3.5 Indexación de elementos.\nDel mismo modo que podíamos acceder a los elementos de un vector podemos acceder a los elementos de un array, la única diferencia es que en este caso hay que indicar tantos índices como dimensión tenga el array.\n\n# EJEMPLOS CON MATRICES:\n# Todos los elementos de una fila\nm[1, ]\n\n[1] 45 23 66 77 33\n\n# Todos los elementos de una columna\nm[, 4]\n\n[1] 77 78\n\n# Elementos de una fila menos los que se encuentran en ciertas columnas\nm[1, -c(3, 5)]\n\n[1] 45 23 77\n\n# Elemetos de una columna menos los que se encuentran en una determinada fila\nm[-2, 1]\n\n[1] 45\n\n# EJEMPLOS CON ARRAYS:\na[1, 3, 2]\n\n[1] 25\n\na[1, , 2]\n\n[1] 17 21 25\n\na[4, 3, ]\n\n[1] 16 28\n\n# Nos quedamos con los elementos que ocupan las filas 2 y 3, todas las columnas, pero \n# solo los que se encuentran en la primera tabla\na[c(2, 3), , -2]\n\n     [,1] [,2] [,3]\n[1,]    6   10   14\n[2,]    7   11   15\n\n\nComo consecuencia de la indexación en una matriz podemos obtener como resultado un vector. Si queremos que el resultado siga siendo uma matriz, incluso si es una matriz formada por una sola fila o columna, podemos usar la siguiente expresión:\n\nm[1, , drop = FALSE]\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,]   45   23   66   77   33\n\nm[, 4, drop = FALSE]\n\n     [,1]\n[1,]   77\n[2,]   78\n\n\nComo ya se ha visto en el apartado anterior, es posible darle nombres a las filas y las columnas de una matriz. Por lo que, la indexación de elementos también se puede realizar mediante estos nombres.\n\nresults[\"row1\", ]\n\n1qrt 2qrt 3qrt 4qrt \n  10   20   30   40 \n\nresults[\"row2\", c(\"1qrt\", \"4qrt\")]\n\n1qrt 4qrt \n  21   13 \n\n\n\n\n5.3.6 Unión de matrices y vectores\nLas funciones cbind() y rbind() nos permiten construir arrays mediante la unión (por columnas o por filas, respectivamente) de vectores o matrices.\n\nm1 = matrix(c(45, 23, 66, 77, 33, 44, 56, 12, 78, 23), 2, 5)\nm1\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,]   45   66   33   56   78\n[2,]   23   77   44   12   23\n\n# Construimos una nueva matriz a partir de la unión del vector (4 ,76) y\n# la 4º columna de m1\nm2 = cbind(c(4, 76), m1[, 4])\nm2\n\n     [,1] [,2]\n[1,]    4   56\n[2,]   76   12\n\nm3 = matrix(rep(12, 20), 4, 5)\nm3\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,]   12   12   12   12   12\n[2,]   12   12   12   12   12\n[3,]   12   12   12   12   12\n[4,]   12   12   12   12   12\n\n# Construimos una nueva matriz a partir de la unión de la fila 1 de m1\n# y la fila 3 de m3\nm4 = rbind(m1[1, ], m3[3, ])\nm4\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,]   45   66   33   56   78\n[2,]   12   12   12   12   12\n\n\n\n\n5.3.7 Operaciones aritméticas\nTanto a las matrices como a los arrays se les aplican las mismas reglas aritméticas que a los vectores a la hora de realizar operaciones aritméticas con ellas.\n\nm = matrix(c(45, 23, 66, 77, 33, 44, 56, 12, 78, 23), 2, 5)\nm\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,]   45   66   33   56   78\n[2,]   23   77   44   12   23\n\nm * 3\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,]  135  198   99  168  234\n[2,]   69  231  132   36   69\n\nm1 = matrix(c(45, 23, 66, 77, 33, 44), 2, 3)\nm1\n\n     [,1] [,2] [,3]\n[1,]   45   66   33\n[2,]   23   77   44\n\nm2 = matrix(c(12, 65, 32, 7, 4, 78), 2, 3)\nm2\n\n     [,1] [,2] [,3]\n[1,]   12   32    4\n[2,]   65    7   78\n\nm1 + m2\n\n     [,1] [,2] [,3]\n[1,]   57   98   37\n[2,]   88   84  122",
    "crumbs": [
      "El lenguaje R",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Tipos de datos</span>"
    ]
  },
  {
    "objectID": "05-data-types.html#listas.",
    "href": "05-data-types.html#listas.",
    "title": "5  Tipos de datos",
    "section": "5.4 Listas.",
    "text": "5.4 Listas.\nUna lista en R consiste en una colección ordeanda de elemntos. Los elementos u objetos almacenados en ella se conocen con el nombre de componentes. A diferencia de los vectores o arrays, los componentes de una lista pueden ser de diferente tipo. A estos componentes les podemos dar nombres igual que hacíamos en los arrays.\n\n5.4.1 Creacción de una lista.\nPara crear una lista no hay más que darle un nombre a la lista e indicarle a la función list() cuales van a ser los elementos que vamos a guardar en ella. A cada uno de estos elementos le podemos dar un nombre.\n\n# Lista de tres componentes que llamamos stud.id, stud.name y stud.marks\nmy.lst = list(stud.id=69449, stud.name=\"Ana\", stud.marks=c(5.25, 10, 7.5, 9.25))\n\nNo es obligatorio darle nombre a los componentes de una lista cuando la creamos. También existe la opción de darles nombre después de haber creado la lista.\n\nmy.lst2 = list(12584, \"Marcos\", c(8.5, 10, 17,9.75))\nmy.lst2\n\n[[1]]\n[1] 12584\n\n[[2]]\n[1] \"Marcos\"\n\n[[3]]\n[1]  8.50 10.00 17.00  9.75\n\nnames(my.lst2) = c(\"id\", \"name\", \"marks\")\nmy.lst2\n\n$id\n[1] 12584\n\n$name\n[1] \"Marcos\"\n\n$marks\n[1]  8.50 10.00 17.00  9.75\n\n\nLa función unlist() nos devuelve un vector con tantos elementos como elementos hubiera en la lista que se le pasa por parámetro. Como los vectores solo pueden estar compuestos por elementos del mismo tipo, el uso de esta función además provocará cambios en los tipos de elementos. Lo más normal es que transforme todos los elementos a cadenas de caracteres.\n\nunlist(my.lst2)\n\n      id     name   marks1   marks2   marks3   marks4 \n \"12584\" \"Marcos\"    \"8.5\"     \"10\"     \"17\"   \"9.75\" \n\n\n\n\n5.4.2 Indexación de elementos.\nSi a la hora de crear nuestra lista le hemos dado nombre a los componentes, podemos acceder a ellos a través de su nombre. Si no le hemos dado nombre, siempre podemos acceder a ellos a través del índice de la posición que ocupan.\n\nmy.lst$stud.id\n\n[1] 69449\n\nmy.lst$stud.name\n\n[1] \"Ana\"\n\n# Accedemos al valor del componente que se encuentra en la 1º posición\nmy.lst[[1]]\n\n[1] 69449\n\n# Accedemos al valor del componente que se encuentra en la 3º posición\nmy.lst[[3]]\n\n[1]  5.25 10.00  7.50  9.25\n\n\nSi realizamos la indexación por índice de posición y solo utilizamos un corchete, el resultado que obtenemos es una sublista de la lista original con el componente deseado.\n\nmy.lst[1]\n\n$stud.id\n[1] 69449\n\n# Comprobamos que el tipo de dato es diferente\nmode(my.lst[1])\n\n[1] \"list\"\n\nmode(my.lst[[1]])\n\n[1] \"numeric\"\n\n\n\n\n5.4.3 Añadir y quitar elementos a una lista.\nDada una lista siempre podemos añadir y quitar elementos de ella. Veamos un ejemplo:\n\nmy.lst$parents.names = c(\"Ana\", \"Miguel\")\nmy.lst\n\n$stud.id\n[1] 69449\n\n$stud.name\n[1] \"Ana\"\n\n$stud.marks\n[1]  5.25 10.00  7.50  9.25\n\n$parents.names\n[1] \"Ana\"    \"Miguel\"\n\nmy.lst = my.lst[-5]\nmy.lst\n\n$stud.id\n[1] 69449\n\n$stud.name\n[1] \"Ana\"\n\n$stud.marks\n[1]  5.25 10.00  7.50  9.25\n\n$parents.names\n[1] \"Ana\"    \"Miguel\"\n\n\nOtra opción de añadir elementos a una lista es concatenando varias listas.\n\nother = list(age = 19, sex =\"male\")\nlst = c(my.lst, other)\nlst\n\n$stud.id\n[1] 69449\n\n$stud.name\n[1] \"Ana\"\n\n$stud.marks\n[1]  5.25 10.00  7.50  9.25\n\n$parents.names\n[1] \"Ana\"    \"Miguel\"\n\n$age\n[1] 19\n\n$sex\n[1] \"male\"\n\n\nMediante la función length() podemos saber el número de componentes de una lista en todo momento.\n\nlength(my.lst)\n\n[1] 4",
    "crumbs": [
      "El lenguaje R",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Tipos de datos</span>"
    ]
  },
  {
    "objectID": "05-data-types.html#data-frames.",
    "href": "05-data-types.html#data-frames.",
    "title": "5  Tipos de datos",
    "section": "5.5 Data Frames.",
    "text": "5.5 Data Frames.\n\nLos datos estructurados son aquellos que podemos organizar aplicando un esquema previo (estructura), que es conocido antes de realizar su análisis y se mantiene fijo.\n\nEjemplo: una tabla de una base de datos relacional, un archivo CSV.\n\nLos datos no estructurados son aquellos que no podemos organizar a priori, puesto que pueden contener cualquier tipo de información en cualquier formato. Así pues, primero debemos analizar dicho contenido para extraer información valiosa.\n\nEjemplo: transcripciones de conversaciones sobre las que aplicamos PLN.\n\n\nEl Data Frame es la estructura de datos recomendada para almacenar tablas de datos en R. Desde el punto de vista estructural son similares a las matrices, ya que se trata de estructuras de datos bi-dimensionales. Sin embargo, al contrario que las matrices, e imitando el comportamiento de las listas, los datos que se almacenan en un Data Frame pueden ser de diferentes tipos. En este sentido pueden verse como una extensión de las listas. En definitiva, se trata de estructuras de almacenamiento bi-dimensioanles de datos heterogéneos.\n\n5.5.1 Creacción de un Data Frame.\nPara la creacción de un Data Frame en R tenemos la función data.frame(). La forma de definir el Data Frame es equivalente a la lista, indicamos el nombre de cada columna y los valores que se van almacenar en ella.\nEs conveniente identificar cada columna con una variable y cada fila con una observación (compuesta por el conjunto de valores de cada una de las variables).\n\nmy.dataset = data.frame(site=c('A','B','A','A','B'),\n                        estacion=c('Inverno','Verano','Verano','Primavera','Otoño'),\n                        pH = c(7.4, 6.3, 8.6, 7.2, 8.9))\nmy.dataset\n\n  site  estacion  pH\n1    A   Inverno 7.4\n2    B    Verano 6.3\n3    A    Verano 8.6\n4    A Primavera 7.2\n5    B     Otoño 8.9\n\n\nNormalmente crearemos un Data Frame a partir de la lectura de los datos de un fichero. En el siguiente capítulo veremos como se realiza esta operación.\n\n\n5.5.2 Características de un Data Frame.\nPodemos conocer el número de filas, columnas y la dimensión de un Data Frame mediante las funciones nrow(), ncol() y dim().\n\nnrow(my.dataset)\n\n[1] 5\n\nncol(my.dataset)\n\n[1] 3\n\ndim(my.dataset)\n\n[1] 5 3\n\n\nTambién podemos conocer o cambiar el nombre de las columnas de un Data Frame mediante la función names().\n\nnames(my.dataset)\n\n[1] \"site\"     \"estacion\" \"pH\"      \n\nnames(my.dataset)=c(\"area\",\"season\",\"pH\")\nmy.dataset\n\n  area    season  pH\n1    A   Inverno 7.4\n2    B    Verano 6.3\n3    A    Verano 8.6\n4    A Primavera 7.2\n5    B     Otoño 8.9\n\n\n\n\n5.5.3 Indexación de elementos.\nPodemos acceder a los elementos de un Data Frame del mismo modo que accedemos a los elementos de una matriz, tanto por su posición como por el nombre de la columna.\n\nmy.dataset[3, 2]\n\n[1] \"Verano\"\n\n# Acceso a una columna determina mediante su nombre:\nmy.dataset$pH\n\n[1] 7.4 6.3 8.6 7.2 8.9\n\nmy.dataset[[\"site\"]]\n\nNULL\n\n\nAprovechando la capacidad de R para obtener sub-secciones, esta opción también es posible con un Data Frame. Es decir, a partir de un Data Frame podemos obtener otro Data Frame que consista solo en una parte del primero. Esta operación se realiza mediante la aplicación de una máscara, que no es más que una expresión lógica.\n\n# Construimos un nuevo Data Frame con las filas que tengan pH mayores que 7:\nmy.dataset[my.dataset$pH&gt;7, ]\n\n  area    season  pH\n1    A   Inverno 7.4\n3    A    Verano 8.6\n4    A Primavera 7.2\n5    B     Otoño 8.9\n\n# El nuevo Data Frame está formado solo por los valores de pH de aquellas filas que tienen\n# site=A:\nmy.dataset[my.dataset$site == \"A\", \"pH\"]\n\nnumeric(0)\n\n# Nos quedamos con las filas que tienen season=Summer y las columnas site y pH:\nmy.dataset[my.dataset$season == \"Summer\", c(\"area\",\"pH\")]\n\n[1] area pH  \n&lt;0 rows&gt; (o 0- extensión row.names)\n\n\nOtra opción de obtener una sub-sección de un Data Frame es usando la función subset().\n\nsubset(my.dataset, pH &gt;8)\n\n  area season  pH\n3    A Verano 8.6\n5    B  Otoño 8.9\n\nsubset(my.dataset, season == \"Summer\", season:pH)\n\n[1] season pH    \n&lt;0 rows&gt; (o 0- extensión row.names)\n\n\nLa diferencia con el procedimiento anterior es que, si queremos asignar nuevos valores a una sub-sección de un Data Frame, no podemos hacerlo con la función subset(), tenemos que obtener la sub-sección con la aplicación de una máscara.\n\nmy.dataset[my.dataset$season == \"Summer\", \"pH\"] = \n  my.dataset[my.dataset$season == \"Summer\", \"pH\"]+1\n\n\n\n5.5.4 Añadir nuevas columnas.\nSe pueden añadir nuevas columnas a un Data Frame del mismo modo que hacíamos con las listas. La única restricción que debemos tener en cuenta es que la nueva columna debe tener el mismo número de filas que las anteriores.\n\nmy.dataset$N03 = c(234.5, 256.6, 654.1, 356.7, 776.4)\nmy.dataset\n\n  area    season  pH   N03\n1    A   Inverno 7.4 234.5\n2    B    Verano 6.3 256.6\n3    A    Verano 8.6 654.1\n4    A Primavera 7.2 356.7\n5    B     Otoño 8.9 776.4\n\n\n\n\n5.5.5 Extensión de Data Frames: tibble.\nLos paquetes tibble (Wickham et al., 2016) y dplyr (Wickham and Fancis, 2015) nos proporcionan un conjunto de operaciones muy útil para facilitar la manipulación de datos. El paquete tiblle define la estructura de datos denominada tibbles considerada como un caso especial de Data Frame. Los tibbles modifican algunos de los comportamientos estandar que hemos visto de los Data Frame:\n\nlos tibbles nunca cambian las columnas caracter en factores como hacen los Data Frame por defecto\nlos tibbles tienen más flexibilidad a la hora de nombrar a las columnas.\nlos métodos de representación que tienen los tibbles son más convenientes que los de los Data Frame cuando se trabaja con grandes cantidades de datos.\n\nPara crear un tibble utilizamos la función tibble() de R. Su funcionamiento es muy similar al de la función data.frame(). Como se puede observar en el siguiente ejemplo, los valores de cada columna se calculan secuencialmente permitiendonos usar los valores de la columna anterior, y los vectores de caracteres no se convierten en factores.\n\nlibrary(tibble)\ndat = tibble(TempCels = sample(-10:40, size=100, replace=TRUE),\n             TempFahr = TempCels*9/5+32,\n             Location =rep(letters[1:2], each=50))\ndat\n\n# A tibble: 100 × 3\n   TempCels TempFahr Location\n      &lt;int&gt;    &lt;dbl&gt; &lt;chr&gt;   \n 1       23     73.4 a       \n 2       13     55.4 a       \n 3       17     62.6 a       \n 4       33     91.4 a       \n 5        6     42.8 a       \n 6       -5     23   a       \n 7       17     62.6 a       \n 8       -3     26.6 a       \n 9        8     46.4 a       \n10       23     73.4 a       \n# ℹ 90 more rows\n\n\nCualquier Data Frame estandar se puede convertir en un tibble. Como ejemplo para visualizar este comportamiento vamos a usar el famoso dataset Iris, está disponible directamente en R y contiene 150 filas con 5 variables.\n\n# Cargamos el dataset Iris en un Data Frame estandar\ndata(iris)\ndim(iris)\n\n[1] 150   5\n\nclass(iris)\n\n[1] \"data.frame\"\n\nlibrary(tibble)\n# Convertimos el Data Frame a tibble\nir = as_tibble(iris)\n# No hemos creado una nueva copia del Data Frame. El nuevo objeto es todavía de la clase\n# data.frame pero también pertenece a las clases tbl_df (la clase de los tibble) y tbl\n# (es una generealización de la anterior).\nclass(ir)\n\n[1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n\nir\n\n# A tibble: 150 × 5\n   Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n          &lt;dbl&gt;       &lt;dbl&gt;        &lt;dbl&gt;       &lt;dbl&gt; &lt;fct&gt;  \n 1          5.1         3.5          1.4         0.2 setosa \n 2          4.9         3            1.4         0.2 setosa \n 3          4.7         3.2          1.3         0.2 setosa \n 4          4.6         3.1          1.5         0.2 setosa \n 5          5           3.6          1.4         0.2 setosa \n 6          5.4         3.9          1.7         0.4 setosa \n 7          4.6         3.4          1.4         0.3 setosa \n 8          5           3.4          1.5         0.2 setosa \n 9          4.4         2.9          1.4         0.2 setosa \n10          4.9         3.1          1.5         0.1 setosa \n# ℹ 140 more rows\n\n\nOtra diferencia fundamental entre los tibbles y los Data Frame es la indexación de elementos. Después de aplicar una máscara a un Data Frame hemos visto que lo que obteníamos era un vector. Sin embargo, con los tibbles esto no pasa, después de aplicar una máscara lo que obtenemos es otro tibble. Veamos esta diferencia de comportamiento en el siguiente ejemplo:\n\niris[1:15, \"Petal.Length\"]\n\n [1] 1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 1.5 1.6 1.4 1.1 1.2\n\nclass(iris[1:15, \"Petal.Length\"])\n\n[1] \"numeric\"\n\n# Con drop=FALSE podemos eliminar este comportamiento de los Data Frame\niris[1:15, \"Petal.Length\",drop=FALSE]\n\n   Petal.Length\n1           1.4\n2           1.4\n3           1.3\n4           1.5\n5           1.4\n6           1.7\n7           1.4\n8           1.5\n9           1.4\n10          1.5\n11          1.5\n12          1.6\n13          1.4\n14          1.1\n15          1.2\n\nclass(iris[1:15, \"Petal.Length\",drop=FALSE])\n\n[1] \"data.frame\"\n\nir[1:15, \"Petal.Length\"]\n\n# A tibble: 15 × 1\n   Petal.Length\n          &lt;dbl&gt;\n 1          1.4\n 2          1.4\n 3          1.3\n 4          1.5\n 5          1.4\n 6          1.7\n 7          1.4\n 8          1.5\n 9          1.4\n10          1.5\n11          1.5\n12          1.6\n13          1.4\n14          1.1\n15          1.2\n\n\nEl paquete dplyr nos proporciona las funciones select() y filter() para hacer indexación de elementos. La función select() se usa pra seleccionar un conjunto de columnas y la función filter() para seleccionar un conjunto de filas.\n\nlibrary(dplyr)\n\n\nAdjuntando el paquete: 'dplyr'\n\n\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n\n\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n\n# Nos quedamos con las filas de la especie \"setosa\", de la cual solo queremos las columnas\n# que se llaman Petal.Width y Petal.Length\nselect(filter(ir, Species==\"setosa\"), Petal.Width,Petal.Length)\n\n# A tibble: 50 × 2\n   Petal.Width Petal.Length\n         &lt;dbl&gt;        &lt;dbl&gt;\n 1         0.2          1.4\n 2         0.2          1.4\n 3         0.2          1.3\n 4         0.2          1.5\n 5         0.2          1.4\n 6         0.4          1.7\n 7         0.3          1.4\n 8         0.2          1.5\n 9         0.2          1.4\n10         0.1          1.5\n# ℹ 40 more rows\n\n# Podemos hacer lo mismo utilizando el operador pipe:\nfilter(ir, Species==\"setosa\") |&gt; select(Petal.Width, Petal.Length)\n\n# A tibble: 50 × 2\n   Petal.Width Petal.Length\n         &lt;dbl&gt;        &lt;dbl&gt;\n 1         0.2          1.4\n 2         0.2          1.4\n 3         0.2          1.3\n 4         0.2          1.5\n 5         0.2          1.4\n 6         0.4          1.7\n 7         0.3          1.4\n 8         0.2          1.5\n 9         0.2          1.4\n10         0.1          1.5\n# ℹ 40 more rows\n\n\nNOTA: el operador pipe (|&gt;) se puede aplicar a cualquier función de R. Significa que, lo que está a su izquierda se pasa como el primer argumento a la función que está a su derecha. Es decir, una expresión del tipo x |&gt; f(y) es equivalente a f(x,y).",
    "crumbs": [
      "El lenguaje R",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Tipos de datos</span>"
    ]
  },
  {
    "objectID": "06-tidy-data.html",
    "href": "06-tidy-data.html",
    "title": "6  Tidy data",
    "section": "",
    "text": "6.1 Principios: “tidy data”\nEn septiembre de 2014, la revista Journal of Statistical Software publicó un artículo de H. Wickham (Wickham, 2014) en el que presentaba algunos principios básicos para estructurar la organización de conjuntos de datos. Su objetivo era facilitar la preparación, modelado y visualización de datos en todas las fases de un proyecto.\nPrimero establecemos un vocabulario de términos estándar:\nSegún este artículo, los tres principios básicos para que un conjunto de datos se organice de acuerdo a las normas de tidy data son (Wickham, 2014):\nPor “tipo de unidad de observación” podemos entender una persona, un tipo de objeto o cualquier otro tipo de elemento que constituya un tipo de unidad de análisis en nuestro estudio. Cualquier conjunto de datos que no siga estos principios se considera messy data.\nEstos principios no son en absoluto originales de Wickham, sino que el autor se limitó a reexpresar algunos principios de normalización del álgebra relacional de Codd (Codd, 1990), aunque en un lenguaje más accesible para estadísticos y otros profesionales del análisis de datos que no tengan, necesariamente, conocimientos de teoría de bases de datos.\nPodemos notar rápidamente la influencia de estos principios en un ejemplo sencillo. Consideremos la siguiente tabla, presentada como ejemplo en el artículo original de Wickham, con datos de un hipotético análisis clínico sobre pacientes:\nSi tenemos alguna experiencia previa analizando datos con herramientas como hojas de cálculo, y reflexionamos un poco, es muy probable que hayamos visto con anterioridad una estructura de organización de datos parecida. Ahora, presentamos una segunda versión, con los mismos datos pero organizados de manera distinta:\nSi comparamos la tabla Tabla 6.1 y la tabla Tabla 6.2 podemos comprobar que contienen la misma información. Sin embargo, la estructura es diferente. En la tabla Tabla 6.1 la primera columna contiene los nombres de los pacientes, mientras que las dos siguientes hacia la derecha contienen los resultados de la prueba de cada paciente para el tratamiento A y el B, respectivamente. En su lugar, en la Tabla Tabla 6.2 las filas recogen los datos de todos los pacientes para cada tratamiento, y las columnas corresponden a los datos de cada paciente.\nAunque en ambos casos los datos son “correctos” en sentido técnico (la información es la misma en ambos casos y suponemos que no hay fallos en la introducción de datos), enseguida podemos imaginar que un script de R (o cualquier otro lenguaje) que espere recibir los datos en el formato de la Tabla Tabla 6.1 y, en cambio, los reciba en el formato de la Tabla Tabla 6.2 seguramente va a devolver errores. Y ello pese a que la información es correcta en ambos casos.\nEn consecuencia, es importante establecer explícitamente un acuerdo entre los investigadores para organizar siempre los datos de la misma manera. De esta forma, sabemos qué formato de datos esperamos encontrar y se puede intentar “reclamar” al origen de los datos que siga esta convención de representación de la información (aunque no siempre esto es posible).\nLa tabla Tabla 6.3 muestra cómo se representan los datos siguiendo la convención establecida por las reglas de tidy data:\nSiempre que haya variables categóricas involucradas, el formato tidy data obliga a poner una fila nueva por cada persona y nivel registrado de cada variable categórica. Ciertamente, esto obliga a repetir información en varias filas (por ejemplo, nombre de tratamiento), y puede parecer que no es muy eficiente computacionalmente. No obstante, como veremos después R guarda los niveles de las variables categóricas internamente como números enteros, y solo cuando tiene que mostrar esa información en pantalla “traduce” esos códigos a la etiqueta de identificación que le hemos asignado a cada nivel. Así que no hay tanta pérdida de eficiencia como podría parecer a primera vista.",
    "crumbs": [
      "El lenguaje R",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Tidy data</span>"
    ]
  },
  {
    "objectID": "06-tidy-data.html#principios-tidy-data",
    "href": "06-tidy-data.html#principios-tidy-data",
    "title": "6  Tidy data",
    "section": "",
    "text": "Un conjunto de datos es una colección de valores, que pueden ser cuantitativos (numéricos) o cualitativos (categóricos).\nUna variable representa el conjunto de todos los valores que miden el mismo atributo (altura, temperatura, duración, etc.).\nUna observación contiene todos los valores medidos sobre la misma unidad de análisis (una persona, un día, una provincia, etc.) para todos los atributos.\n\n\n\nCada variable está en una columna.\nCada observación está en una fila.\nCada tipo de unidad de observación forma una tabla.\n\n\n\n\n\n\n\nTabla 6.1: Ejemplo de un conjunto de datos que no sigue los principios de tidy data.\n\n\n\n\n\n\ntreatment_a\ntreatment_b\n\n\n\n\nJohn Smith\n—\n2\n\n\nJane Doe\n16\n11\n\n\nMary Johnson\n3\n1\n\n\n\n\n\n\n\n\n\n\nTabla 6.2: El mismo dataset que en la Tabla Tabla 6.1, pero con estructura diferente.\n\n\n\n\n\n\nJohn Smith\nJane Doe\nMary Johnson\n\n\n\n\ntreatment_a\n—\n16\n3\n\n\ntreatment_b\n2\n11\n1\n\n\n\n\n\n\n\n\n\n\n\n\nTabla 6.3: El mismo dataset, pero ahora en formato tidy data.\n\n\n\n\n\nname\ntreatment\nresult\n\n\n\n\nJohn Smith\na\n—\n\n\nJane Doe\na\n16\n\n\nMary Johnson\na\n3\n\n\nJohn Smith\nb\n2\n\n\nJane Doe\nb\n11\n\n\nMary Johnson\nb\n1\n\n\n\n\n\n\n\n\nHay 3 variables (nombre de paciente, tratamiento y resultado), una en cada columna.\nHay 6 filas, una por cada unidad de observación (aquí la unidad de observación es la combinación paciente + tratamiento).\nEn la intersección de cada fila y cada columna hay un solo dato.",
    "crumbs": [
      "El lenguaje R",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Tidy data</span>"
    ]
  },
  {
    "objectID": "06-tidy-data.html#el-paquete-tidyverse",
    "href": "06-tidy-data.html#el-paquete-tidyverse",
    "title": "6  Tidy data",
    "section": "6.2 El paquete tidyverse",
    "text": "6.2 El paquete tidyverse\nEl sitio web http://www.tidyverse.org centraliza gran parte de la información general sobre la filosofía de trabajo y los paquetes principales que componen el ecosistema del tidyverse. En particular en la URL https://www.tidyverse.org/packages/ encontramos una página que resume la lista de principales paquetes que podemos encontrar.\nAunque en este capítulo nos centraremos sobre todo en dplyr y tidyr, existen muchos otros paquetes que proporcionan funcionalidades extra muy interesantes, tanto para trabajo con tipos de datos específicos (forcats, lubridate, hms) para operaciones de comuniación (httr, rvest), o para estructurar y unificar informes sobre modelos y anotación de datasets con resultados (broom). En la siguiente sección se muestra una tabla con los principales paquetes que, en este momento, son utilizados con frecuencia en el tidyverse.\nMención especial merece un importante esfuerzo que se está realizando en la actualidad para modernizar el proceso de diseño, implementación, ajuste y mantenimiento de modelos, siguiendo los principios de tidy data y completamente integrado con el resto de elementos del tidyverse. Aunque H. Wickham inició este trabajo con el paquete modelr (Wickham et al., 2023), pronto fue evidente que se necesitaría mucho más esfuerzo para llevar la inicitiva a buen puerto. En los últimos años, RStudio (la empresa en la que Wickham trabaja) ha contratado a algunos de los más destacados desarrolladores de la comunidad R en todo el mundo (e.g. Max Kuhn, Jenny Brian, etc.) para acelerar el progreso en este frente.\nKuhn, principal autor del paquete caret (Kuhn & Johnson, 2013), uno de los más usados para diseño e implementación de modelos de aprendizaje máquina en R, se encarga ahora de liderar el desarrollo de tidymodels, un metapaquete similar a tidyverse que automatiza la instalación y carga de un conjunto de paquetes (algunos existentes en tidyverse y otros nuevos) para desarrollo y evaluación de modelos. Por el momento, aunque conviene no pereder de vista esta iniciativa el proyecto sigue todavía lejos de alcanzar una versión estable y consolidada.\n\n6.2.1 Resumen de paquetes principales en tidyverse\nLa tabla Tabla 6.4 resume algunos de los paquetes más importantes que encontraremos en el ecosistema tidyverse.\n\n\n\nTabla 6.4: Paquetes relevantes del ecosistema tidyverse.\n\n\n\n\n\n\n\n\n\nPaquete\nDescripción\n\n\n\n\ntibble\nTipo de datos básico para almacenar tablas de datos, similar a un data frame pero con nuevas funcionalidades\n\n\ndplyr\nProporciona una gramática para manipulación de datos, inspirada en las operaciones que se pueden realizar en bases de datos\n\n\ntidyr\nHerramientas que ayudan a transformar los datos para que cumplan las reglas de tidy data\n\n\nggplot2\nSistema que proporciona un lenguaje declarativo para crear visualizaciones de datos, basado en una gramática de gráficos. Siguen un procedimiento estructurado para describir el diseño del gráfico a realizar\n\n\nreadr\nFunciones eficientes para lectura/escritura de datos estructurados, que proprociona herramientas para resolver problemas comunes en este proceso\n\n\npurrr\nHerramientas para programación funcional con R, que permite reemplazar bucles (como for) por código más eficiente, expresivo y conciso\n\n\nstringr\nFunciones para operativizar el trabajo con cadenas de caracteres en el contexto del tidyverse\n\n\nforcats\nFunciones para trabajo con variables categóricas (llamadas factores en R)\n\n\n\n\n\n\n\n\n6.2.2 Método de trabajo con tidyverse\nEl método de trabajo en tidyverse suele estar fuertemente ligado a la utilización del operador pipe (|&gt;). Esencialmente, este operador simplifica la sintaxis necesaria para realizar llamadas anidadas a funciones, de forma que el resultado de la operación anterior actúe como entrada del siguiente paso. Imaginemos que tenemos un objeto similar a un data frame (en la siguiente sección se introducen los objetos tibble) llamado df, al que queremos aplicar dos funciones de preparación de datos:\n\nf2(f1(df), arg_f2)  # Se complica rápido con muchas funciones\n                    # y es difícil de leer. La fución f2 toma\n                    # un argumento adicional para definir la operación\n                    # a realizar\n\nPor el contrario, si usamos el operador |&gt; podemos escribir cada paso de la cadena de operaciones en una línea diferente. De esta manera, podemos sintácticamente separar cada paso de nuestra cadena de operaciones, de forma que el código queda mucho más legible:\n\n# x |&gt; f(y) se convierte en f(x, y)\ndf |&gt; \n  f1 |&gt;     # Recibe como primer argumento de entrada df\n  f2(arg_f2) # Recibe el resultado del paso anterior, f1(df)\n             # arg_f2 se pasa a continuación como argumento de entrada\n\n\n\n6.2.3 Objetos tibble\nEl paquete tibble de tidyverse proporciona un tipo de dato especial para representar de forma más eficiente tablas de datos, siguiendo una estructura similar a un data frame pero con características mucho más eficientes.\nVeamos un ejemplo:\n\nhead(iris)  # data frame estándar\n\n  Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n1          5.1         3.5          1.4         0.2  setosa\n2          4.9         3.0          1.4         0.2  setosa\n3          4.7         3.2          1.3         0.2  setosa\n4          4.6         3.1          1.5         0.2  setosa\n5          5.0         3.6          1.4         0.2  setosa\n6          5.4         3.9          1.7         0.4  setosa\n\niris_tibble &lt;- as_tibble(iris)\nprint(iris_tibble)\n\n# A tibble: 150 × 5\n   Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n          &lt;dbl&gt;       &lt;dbl&gt;        &lt;dbl&gt;       &lt;dbl&gt; &lt;fct&gt;  \n 1          5.1         3.5          1.4         0.2 setosa \n 2          4.9         3            1.4         0.2 setosa \n 3          4.7         3.2          1.3         0.2 setosa \n 4          4.6         3.1          1.5         0.2 setosa \n 5          5           3.6          1.4         0.2 setosa \n 6          5.4         3.9          1.7         0.4 setosa \n 7          4.6         3.4          1.4         0.3 setosa \n 8          5           3.4          1.5         0.2 setosa \n 9          4.4         2.9          1.4         0.2 setosa \n10          4.9         3.1          1.5         0.1 setosa \n# ℹ 140 more rows\n\n\nComo vemos, un objeto de este tipo es muy similar a un data frame, pero añade explícitamente en la salida información sobre el tipo de dato de cada columna. Un aspecto importante que resaltaremos más adelante es que, por defecto, tibble intenta asignar el tipo de dato adecuado a cada columna, excepto en un caso: si la columna contiene cadenas de caracteres como valores entonces no los transforma automáticamente a variable categórica en R (las variables categóricas en R, recordemos, se llaman factores). En su lugar, deja los valores de la columna como objetos string (en la cabecera se lee tipo &lt;str&gt;). Si queremos que se conviertan a tipo de dato categórico lo tendremos que indicar explícitamente (veremos cómo más adelante). Comentamos este aspecto porque, en el ejemplo anterior, vemos que la columna del tipo de flor sí se ha identificado como de tipo factor (&lt;fct&gt;), pero esto se debe a que originalmente la columna iris$Species ya era de tipo factor:\n\nclass(iris$Species)\n\n[1] \"factor\"\n\n\nEsto no es la norma habitual cuando leemos datos de fuentes externas, por ejemplo de un fichero, una API o una base de datos, por lo que conviene recordar esta característica para no arrastrar el error en pasos posteriores.\nAdemás, la función str(...) permite obtener información adicional muy útil sobre el formato de las columnas de un objeto tibble:\n\nstr(iris_tibble)\n\ntibble [150 × 5] (S3: tbl_df/tbl/data.frame)\n $ Sepal.Length: num [1:150] 5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ...\n $ Sepal.Width : num [1:150] 3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ...\n $ Petal.Length: num [1:150] 1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ...\n $ Petal.Width : num [1:150] 0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ...\n $ Species     : Factor w/ 3 levels \"setosa\",\"versicolor\",..: 1 1 1 1 1 1 1 1 1 1 ...\n\n\nMencionar de pasada que existe también data.table, competidor de este paquete (y con muy buen rendimiento…)",
    "crumbs": [
      "El lenguaje R",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Tidy data</span>"
    ]
  },
  {
    "objectID": "06-tidy-data.html#preparación-de-datos-con-tidyverse-tidyr",
    "href": "06-tidy-data.html#preparación-de-datos-con-tidyverse-tidyr",
    "title": "6  Tidy data",
    "section": "6.3 Preparación de datos con tidyverse: tidyr",
    "text": "6.3 Preparación de datos con tidyverse: tidyr\nPuesto que tidyverse asume que los datos se organizarán en tablas que siguen estrictamente sus principios de organización, el primer paso es asegurarnos de que, en efecto, los datos de entrada cumplen estos requisitos.\nEn caso contrario, el paquete tidyr porporciona una serie de herramientas que nos van a facilitar el trabajo de convertir nuestros datos a este formato. Algunas de ellas se resumen en la Tabla Tabla 6.5.\n\n\n\nTabla 6.5: Principales funciones del paquete tidyr\n\n\n\n\n\n\n\n\n\nFunciones\nDescripción\n\n\n\n\nPivoting\nOperación: Cambiar estructura y dimensiones\n\n\npivot_longer()\nReemplaza a la función gather() en versiones anteriores del paquete. Disminuye el número de columnas e incrementa el número de filas de la tabla (haciéndola más alargada. Por ejemplo, permite colapsar varias columnas cuyos títulos son valores de una variable en una sola columna con un nuevo nombre\n\n\npivot_wider()\nReemplaza a la función spread() en versiones anteriores del paquete. Aumenta el número de columnas y disminuye el número de filas, haciendo la tabla más ancha. Por ejemplo, permite expandir los nombres de variables que sean valores de una sola columna en varias columnas, con los valores correspondientes en cada una\n\n\nNested data\nOperación: Anidar datos o extraer datos anidados\n\n\nnest()\nPermite anidar tablas tidy data dentro de otras, de modo que una columna de la tabla sea una lista de data frames (tibbles, en tidyverse)\n\n\nunnest()\nImplementa la operación contraria a nest() extrayendo las data frames anidada en una columna anexándolas por filas y replicando el resto de columnas para alinear los datos\n\n\nRectangling\nOperación: Tratamiento de lista de datos anidadas (JSON, XML)\n\n\nunnest_longer()\nToma cada elemento de una columna-lista y lo convierte en una nueva fila\n\n\nunnest_wider()\nToma cada argumento de una columna lista y lo convierte en una nueva columna\n\n\nunnest_auto()\nIntenta adivinar la operación apropiada para preparar los datos\n\n\n\n\n\n\nLa página web del paquete tidyr https://tidyr.tidyverse.org/ incluye varios artículos y un enlace a la hoja resumen actualizada con la explicación de cada función incluida.\nNosotros vamos a incluir, a modo de ejemplo, dos casos de uso de las herramientas pivot_longer y pivot_wider. En la página web del paquete tidyr, el artículo Pivoting describe varios ejemplos utilizando datasets de casos reales. Sin embargo, para entender mejor estas dos funciones vamos a emplear otro ejemplo, extraído del R Cookbook de W. Chang1:\n\n# En este ejemplo se usa la función read.table(), que\n# permite leer rápidamente datos escritos directamente\n# como strings en la consola o en nuestros scripts.\n\n# Ejemplo de tabla en formato wide\nexperiment_wide &lt;- read.table(header=TRUE, text='\n subject sex control cond1 cond2\n       1   M     7.9  12.3  10.7\n       2   F     6.3  10.6  11.1\n       3   F     9.5  13.1  13.8\n       4   M    11.5  13.4  12.9\n')\n\n# Ejemplo de tabla en formato long\nexperiment_long &lt;- read.table(header=TRUE, text='\n subject sex condition measurement\n       1   M   control         7.9\n       1   M     cond1        12.3\n       1   M     cond2        10.7\n       2   F   control         6.3\n       2   F     cond1        10.6\n       2   F     cond2        11.1\n       3   F   control         9.5\n       3   F     cond1        13.1\n       3   F     cond2        13.8\n       4   M   control        11.5\n       4   M     cond1        13.4\n       4   M     cond2        12.9\n')\n\nVeamos cómo cambiar la primera tabla (wide), que además no cumple con las normas de tidy data, al formato de la segunda tabla (long), que además sí cumple con las normas de tidy data:\n\n# Usamos la función pivot_longer()\n# Podemos consultar sus arcumentos escribiendo ?pivot_longer en consola R\n# Argumentos:\n# - cols: columnas de la tabla original que vamos a colapsar en una única columna\n# - names_to: nombre de la columna que contendrá como valores los nombres de las\n# columnas colapsadas, procedentes de la tabla original.\n# - values_to: nombre de la columna que contendrá como valores los valores de las\n# columnas colapsadas, procedentes de la tabla original.\ntib_exp_long &lt;-\n  experiment_wide |&gt;\n  pivot_longer(cols = c('control', 'cond1', 'cond2'), names_to = 'condition',\n               values_to = 'measurement')\ntib_exp_long\n\n# A tibble: 12 × 4\n   subject sex   condition measurement\n     &lt;int&gt; &lt;chr&gt; &lt;chr&gt;           &lt;dbl&gt;\n 1       1 M     control           7.9\n 2       1 M     cond1            12.3\n 3       1 M     cond2            10.7\n 4       2 F     control           6.3\n 5       2 F     cond1            10.6\n 6       2 F     cond2            11.1\n 7       3 F     control           9.5\n 8       3 F     cond1            13.1\n 9       3 F     cond2            13.8\n10       4 M     control          11.5\n11       4 M     cond1            13.4\n12       4 M     cond2            12.9\n\n\nDe forma equivalente, se puede pasar de una tabla en formato long a una en formato wide. ¿Por qué es útil esta transformación? En primer lugar porque, aunque los paquetes de tidyverse esperan tablas de datos que cumplan con las reglas de tidy data, muchos otros paquetes de R no lo esperarán. Antes al contrario, nos obligan a formatear las tablas en una estructura wide. Esto es habitual, por ejemplo, en datos para análisis en ciencias sociales de sucesiones de eventos a un mismo individuo (como encuentas de seguimiento realizadas cada cierto intervalo). Otro motivo es que, en ocasiones, no podemos transformar una tabla messy data en una tabla tidy data en un solo paso. En su lugar, tenemos que hacer varias transformaciones en ambos sentidos hasta completar el proceso.\nEn nuestro ejemplo, vemos cómo volver a dejar los datos en el formato wide original:\n\n# Usamos la función pivot_wider()\n# Podemos consultar sus argumentos escribiendo ?pivot_wide en consola R\n# Argumentos:\n# - \ntib_exp_wide &lt;-\n  experiment_long |&gt;\n  pivot_wider(names_from = 'condition', values_from = 'measurement')\ntib_exp_wide\n\n# A tibble: 4 × 5\n  subject sex   control cond1 cond2\n    &lt;int&gt; &lt;chr&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n1       1 M         7.9  12.3  10.7\n2       2 F         6.3  10.6  11.1\n3       3 F         9.5  13.1  13.8\n4       4 M        11.5  13.4  12.9\n\n\nLa siguiente figura ilustra de forma más explícita el proceso de conversión de formato wide a formato long:\nUna vez que hemos garantizado que los datos de nuestro proyecto son tidy data, podemos emplear las potentes herramientas de consulta, manipulación y actualización de datos que nos proporciona el paquete dplyr. No obstante, en ocasiones también tendremos que utilizar estas funciones en combinación con las de tidyr para resolver problemas complicados de preparación de datos.",
    "crumbs": [
      "El lenguaje R",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Tidy data</span>"
    ]
  },
  {
    "objectID": "06-tidy-data.html#consulta-manipulación-y-actualización-de-datos-dplyr",
    "href": "06-tidy-data.html#consulta-manipulación-y-actualización-de-datos-dplyr",
    "title": "6  Tidy data",
    "section": "6.4 Consulta, manipulación y actualización de datos: dplyr",
    "text": "6.4 Consulta, manipulación y actualización de datos: dplyr\nEl paquete dplyr proporciona dentro de tidyverse todas las funciones para consulta y manipulación de datos en nuestras tablas. En general, la lista de funciones proporcionada se asemeja (a propósito) a la lista de funciones que podemos encontrar en lenguajes de manipulación de datos en sistemas de bases de datos, tales como el conocido SQL (Structured Query Language). Sin embargo, para facilitar la accesibilidad a usuarios sin muchos conocimientos sobre bases de datos, los nombres de las funciones de dplyr suelen ser más claros y explícitos.\n\n6.4.1 Funciones principales en dplyr\nLa Tabla Tabla 6.6 resume las principales funciones del paquete dplyr.\n\n\n\nTabla 6.6: Principales funciones del paquete dplyr\n\n\n\n\n\n\n\n\n\nFunciones\nDescripción\n\n\n\n\nBásicas\nOperaciones básicas de recuperación de datos y creación de nuevas variables\n\n\nselect()\nSelecciona las columnas de la tabla que se van a devolver como resultado\n\n\nfilter()\nFiltra filas de la tabla, solo se devuelven las que cumplan las condiciones impuestas mediante una expresión lógica (simple o compuesta)\n\n\nsummarise()\nCalcula estadísticos resumen sobre las columnas de la tabla que se van a recuperar; en combinación con group_by() calcula los resúmenes por cada grupo identificado\n\n\narrange()\nOrdena las filas que se van a devolver, según los valores de una o varias variables; el orden puede ser creciente o decreciente; admite variables numéricas o categóricas (orden alfabético)\n\n\nmutate()\nCrea nuevas columnas a partir de valores de otras columnas ya presentes en la tabla; los valores se pueden combinar mediante múltiples operaciones\n\n\nAgrupación\nIndica que las operaciones de sucesivos pasos se calcularán por grupos, identificados segun los valores de una o varias variables (columnas)\n\n\ngroup_by()\nAgrupar por el valor de una o varias variables\n\n\nFunciones de dos (o más) tablas\nPermiten combinar valores de dos tablas (operaciones con conjuntos, álgebra relacional)\n\n\nMutating joins\nCombinan dos o más tablas atendiendo a valores en las columnas\n\n\ninner_join()\nCombina dos o más tablas, dejando solo las filas con valores coincidentes en una o varias columnas de ambas o todas las tablas\n\n\nleft_join()\nCombina dos tablas, mostrando todos los valores de una o varias columnas de la primera tabla; si la segunda tabla tiene valores coincidentes en la columna(s) indicada(s) se muestra la correspondencia, si no, se muestra un nulo\n\n\nright_join()\nCombina dos tablas, mostrando todos los valores de una o varias columnas de la segunda tabla; si la primera tabla tiene valores coincidentes en la columna(s) indicada(s) se muestra la correspondencia, si no, se muestra un nulo\n\n\nfull_join()\nRealiza el producto cartesiano entre las filas de las dos tablas, es decir, se combina cada fila de la primera tabla con todas las filas de la segunda tabla\n\n\nFiltering joins\nUnen dos o más tablas pero devolviendo solo filas de la primera tabla\n\n\nsemi_join()\nDevuelve datos de la primera tabla que tengan coincidencias en la segunda, atendiendo a los valores de una o varias columnas; no se devuelven datos de la segunda tabla\n\n\nanti_join()\nDevuelve datos de la primera tabla que no tengan coincidencias en la segunda tabla, atendiendo a los valores de una o varias columnas; no se devuelven datos de la segunda tabla\n\n\nOperaciones con conjuntos\nOperaciones con conjuntos\n\n\nunion()\nSe unen todas las filas de ambas tablas (unión de conjuntos)\n\n\nintersect()\nSolo se devuelven las filas con valores coincidentes en ambas tablas (intersección de conjuntos)\n\n\nsetdiff()\nSolo se devuelven las filas con valores no coincidentes en ambas tablas (diferencia de conjuntos)\n\n\n\n\n\n\nEn la página general de “hojas de referencia” (coloquialmente llamadas chuletas o cheatsheets en inglés) de RStudio, podemos encontrar una completa referencia resumen de todas las funciones principales incluidas en dplyr, describiendo qué argumentos recibe cada una y ejemplos de uso (enlace descarga)\n\n\n6.4.2 Ejemplos de uso de dplyr\nSeguidamente, presentamos varios ejemplos de utilización de funciones básicas de dplyr. Únicamente trataremos aquí funciones básicas de consulta de tablas de datos, así como funciones simples de combinación de valores en dos tablas.\nEn estos ejemplos utilizamos el dataset car::UN, con datos de 213 ubicaciones, entre 2009 y 2011, la mayoría de países miembros de la ONU. Para poder acceder a este dataset en nuestro código, tenemos que cargar primero el paquete car. A partir de entonces, tenemos acceso automático a todos los datasets precargados en el paquete, incluido UN:\n\nlibrary(car)\n# Ahora UN está disponible\ncolnames(UN)\n\n[1] \"region\"          \"group\"           \"fertility\"       \"ppgdp\"          \n[5] \"lifeExpF\"        \"pctUrban\"        \"infantMortality\"\n\n# Resumen básico de todas las variables\n# Prestemos atención a que hay valores faltantes (NA's) en todas\n# las columnas\nsummary(UN)\n\n        region      group       fertility         ppgdp         \n Africa    :53   oecd  : 31   Min.   :1.134   Min.   :   114.8  \n Asia      :50   other :115   1st Qu.:1.754   1st Qu.:  1283.0  \n Europe    :39   africa: 53   Median :2.262   Median :  4684.5  \n Latin Amer:20   NA's  : 14   Mean   :2.761   Mean   : 13012.0  \n Caribbean :17                3rd Qu.:3.545   3rd Qu.: 15520.5  \n (Other)   :20                Max.   :6.925   Max.   :105095.4  \n NA's      :14                NA's   :14      NA's   :14        \n    lifeExpF        pctUrban      infantMortality  \n Min.   :48.11   Min.   : 11.00   Min.   :  1.916  \n 1st Qu.:65.66   1st Qu.: 39.00   1st Qu.:  7.019  \n Median :75.89   Median : 59.00   Median : 19.007  \n Mean   :72.29   Mean   : 57.93   Mean   : 29.440  \n 3rd Qu.:79.58   3rd Qu.: 75.00   3rd Qu.: 44.477  \n Max.   :87.12   Max.   :100.00   Max.   :124.535  \n NA's   :14      NA's   :14       NA's   :6        \n\n\n\n\n\n\n\n\n\nInfo: El paquete carData\n\n\n\nDesde hace algunas versiones, en realidad si solo queremos acceder a los\n     datasets del paquete\ncar\nestos se han separado en un paquete \n     aparte, llamado\ncarData\n. Por tanto, si solo nos interesa \n     acceder a los datos pero no queremos el resto de funciones incluidas en\ncar\npodemos cargar únicamente el paquete\ncarData\n.\n\n\nSin embargo, nosotros en este curso sí vamos a utilizar algunas de las\n     funciones de\ncar\n, por lo que directamente cargamos este \n     paquete. Al cargar\ncar\n, el paquete adicional\ncarData\n se carga también de manera automática.\n\n\n\n\n\nLas variables de cada columna en UN son las siguientes:\n\nregion: Variable categórica que indica la región de la ubicación que se describe en dicha fila. Posibles valores: Africa, Asia, Caribbean, Europe, Latin Amer, North America, NorthAtlantic, Oceania.\ngroup: Un factor con 3 posibles niveles:\n\noecd: Para países miembros de la OCDE (OECD en inglés).\nafrica: Para países en dicho continente; no hay países OECD en este grupo.\nother: Categoría que aglutina a lugares que no pertenecen a ninguno de los dos grupos anteriores.\n\nfertility: Ratio de fertilidad total, medido en número de hijos por mujer.\nppgdp: Productor interior bruto per cápita (PPGDG en inglés), en dólares estadounidenses.\nlifeExpF: Esperanza de vida de las mujeres, medida en años.\npctUrban: Porcentaje de suelo urbanizado en dicho lugar.\ninfantMortality: Muertes infantiles antes de cumplir 1 año por cada 1.000 nacimientos con vida.\n\nVeamos ahora algunos ejemplos de utilización de las funciones más habituales en dplyr(). Antes de comenzar, creamos un objeto tibble a partir del data_frame original.\n\nUN_tibble &lt;- as_tibble(UN, rownames = NA)  # Mantener nombres de fila\n\n\n6.4.2.1 Selección de columnas con select()\n\nSelección de columnas por nombre.\n\nRecupera únicamente los datos de fertilidad y PPGDP de todos los países del estudio.\n\n\n\n# Utilizamos un select para recuperar las columnas por nombre\nUN_tibble |&gt;\n  select(\"fertility\", \"ppgdp\") |&gt;\n  head()\n\n# A tibble: 6 × 2\n  fertility  ppgdp\n      &lt;dbl&gt;  &lt;dbl&gt;\n1      5.97   499 \n2      1.52  3677.\n3      2.14  4473 \n4     NA       NA \n5      5.14  4322.\n6      2    13750.\n\n\n\nSelección de columnas excluyendo algunas.\n\nRecupera todas las columnas excepto el porcentaje de suelo urbanizado.\nRepetimos pero ahora eliminando, además, la esperanza de vida femenina.\n\n\n\n# Quitamos suelo urbanizado\nUN_tibble |&gt;\n  select(-\"pctUrban\") |&gt;\n  head()\n\n# A tibble: 6 × 6\n  region    group  fertility  ppgdp lifeExpF infantMortality\n  &lt;fct&gt;     &lt;fct&gt;      &lt;dbl&gt;  &lt;dbl&gt;    &lt;dbl&gt;           &lt;dbl&gt;\n1 Asia      other       5.97   499      49.5           125. \n2 Europe    other       1.52  3677.     80.4            16.6\n3 Africa    africa      2.14  4473      75              21.5\n4 &lt;NA&gt;      &lt;NA&gt;       NA       NA      NA              11.3\n5 Africa    africa      5.14  4322.     53.2            96.2\n6 Caribbean other       2    13750.     81.1            NA  \n\n# Ahora, quitamos además esperanza de vida\nUN_tibble |&gt;\n  select(-c(\"pctUrban\", \"lifeExpF\")) |&gt;\n  head()\n\n# A tibble: 6 × 5\n  region    group  fertility  ppgdp infantMortality\n  &lt;fct&gt;     &lt;fct&gt;      &lt;dbl&gt;  &lt;dbl&gt;           &lt;dbl&gt;\n1 Asia      other       5.97   499            125. \n2 Europe    other       1.52  3677.            16.6\n3 Africa    africa      2.14  4473             21.5\n4 &lt;NA&gt;      &lt;NA&gt;       NA       NA             11.3\n5 Africa    africa      5.14  4322.            96.2\n6 Caribbean other       2    13750.            NA  \n\n\n\nSelección de columnas por posición.\n\nSelecciona la primera, tercera y cuarta columna de la tabla.\n\n\n\n# Podemos utilizar argumentos numéricos para indicar posición de columna\n# En ese caso, no llevan comillas.\nUN_tibble |&gt;\n  select(1,3,4) |&gt;\n  head()\n\n# A tibble: 6 × 3\n  region    fertility  ppgdp\n  &lt;fct&gt;         &lt;dbl&gt;  &lt;dbl&gt;\n1 Asia           5.97   499 \n2 Europe         1.52  3677.\n3 Africa         2.14  4473 \n4 &lt;NA&gt;          NA       NA \n5 Africa         5.14  4322.\n6 Caribbean      2    13750.\n\n\n\nSelección de un rango consecutivo de columnas.\n\nSelecciona las columnas entre grupo de país y esperanza de vida femenina.\nSelecciona las tres primeras columnas de la tabla.\n\n\n\n# Usamos la notación de rango consecutivo con nombres de columnas\n# Atención: ambos extremos del rango están incluidos en la selección\nUN_tibble |&gt; \n  select(\"group\":\"lifeExpF\") |&gt;\n  head()\n\n# A tibble: 6 × 4\n  group  fertility  ppgdp lifeExpF\n  &lt;fct&gt;      &lt;dbl&gt;  &lt;dbl&gt;    &lt;dbl&gt;\n1 other       5.97   499      49.5\n2 other       1.52  3677.     80.4\n3 africa      2.14  4473      75  \n4 &lt;NA&gt;       NA       NA      NA  \n5 africa      5.14  4322.     53.2\n6 other       2    13750.     81.1\n\n# Para la segunda usamos la misma notación, pero con números de columnas\nUN_tibble |&gt;\n  select(1:3) |&gt;\n  head()\n\n# A tibble: 6 × 3\n  region    group  fertility\n  &lt;fct&gt;     &lt;fct&gt;      &lt;dbl&gt;\n1 Asia      other       5.97\n2 Europe    other       1.52\n3 Africa    africa      2.14\n4 &lt;NA&gt;      &lt;NA&gt;       NA   \n5 Africa    africa      5.14\n6 Caribbean other       2   \n\n\n\nSelección de columnas programáticamente (guardando nombres en una variable).\n\nSimula que tienes un vector de nombres de columnas, que por ejemplo puedas haber calculado en un código anterior. Usa los valores de ese vector para seleccionar las columnas correspondientes de la tabla.\n\n\n\n# Imaginemos que el contenido del vector después de las operaciones es este\nnombres_cols = c(\"fertility\", \"ppgdp\", \"infantMortality\")\n\nUN_tibble |&gt;\n  select(nombres_cols) |&gt;\n  head() \n\nWarning: Using an external vector in selections was deprecated in tidyselect 1.1.0.\nℹ Please use `all_of()` or `any_of()` instead.\n  # Was:\n  data %&gt;% select(nombres_cols)\n\n  # Now:\n  data %&gt;% select(all_of(nombres_cols))\n\nSee &lt;https://tidyselect.r-lib.org/reference/faq-external-vector.html&gt;.\n\n\n# A tibble: 6 × 3\n  fertility  ppgdp infantMortality\n      &lt;dbl&gt;  &lt;dbl&gt;           &lt;dbl&gt;\n1      5.97   499            125. \n2      1.52  3677.            16.6\n3      2.14  4473             21.5\n4     NA       NA             11.3\n5      5.14  4322.            96.2\n6      2    13750.            NA  \n\n\n\n\n6.4.2.2 Selección de filas con filter()\n\nFiltrado de filas usando expresiones lógicas (booleanas).\n\nSelecciona las ubicaciones que pertenezcan al grupo other y tengan un ratio de fertilidad mayor de 2.1.\nSelecciona las ubicaciones que pertenezcan a la región de Europa o Latinoamérica con un producto interior bruto per cápita mayor de 25.000 dólares.\n\n\n\n# Usamos los operadores de comparación lógica de R para imponer las\n# condiciones de selección de datos\nUN_tibble |&gt;\n  filter(group == \"other\" & fertility &gt; 2.1) |&gt;\n  head()\n\n# A tibble: 6 × 7\n  region     group fertility  ppgdp lifeExpF pctUrban infantMortality\n  &lt;fct&gt;      &lt;fct&gt;     &lt;dbl&gt;  &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt;           &lt;dbl&gt;\n1 Asia       other      5.97   499      49.5       23          125.  \n2 Latin Amer other      2.17  9162.     79.9       93           12.3 \n3 Asia       other      2.15  5638.     73.7       52           37.6 \n4 Asia       other      2.43 18184.     76.1       89            6.66\n5 Asia       other      2.16   670.     70.2       29           41.8 \n6 Latin Amer other      2.68  4496.     77.8       53           16.2 \n\n\n\nUN_tibble |&gt;\n  filter((region %in% c(\"Europe\", \"Latin Amer\")) & ppgdp &gt; 25000) |&gt;\n  head()\n\n# A tibble: 6 × 7\n  region group fertility  ppgdp lifeExpF pctUrban infantMortality\n  &lt;fct&gt;  &lt;fct&gt;     &lt;dbl&gt;  &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt;           &lt;dbl&gt;\n1 Europe oecd       1.35 45159.     83.6       68            3.71\n2 Europe oecd       1.84 43815.     82.8       97            3.74\n3 Europe oecd       1.88 55830.     81.4       87            3.91\n4 Europe oecd       1.88 44502.     83.3       85            2.78\n5 Europe oecd       1.99 39546.     84.9       86            3.34\n6 Europe oecd       1.46 39857.     83.0       74            3.49\n\n\n\n\n6.4.2.3 Resúmenes de datos con summarise()\n\nEstadísticos resumen para todos los valores de la tabla, o para los grupos que hayan sido creados si antes hemos llamado a group_by().\n\nCalcula el promedio de fertilidad y de PPGDP de todos los países que pertenecen a la OCDE.\nCalcula el número de países que hay en cada región de la muestra (Nota: consulta la sección “Summary Functions” en la segund página de la hoja resumen de dplyr de RStudio para aprender más funciones útiles que puedes usar con summarise).\n\n\n\n# ¿Qué ocurre si no ponemos el argumento na.rm = TRUE? ¿Por qué?\nUN_tibble |&gt;\n  summarise(avg_fertility = mean(fertility, na.rm = TRUE),\n            avg_ppgdp = mean(ppgdp, na.rm = TRUE))\n\n# A tibble: 1 × 2\n  avg_fertility avg_ppgdp\n          &lt;dbl&gt;     &lt;dbl&gt;\n1          2.76    13012.\n\n\n\nUN_tibble |&gt;\n  filter(!is.na(region)) |&gt;  # Quitamos NA's\n  group_by(region) |&gt;  # Pedimos el resumen agrupados por región\n  summarise(num_countries = n())\n\n# A tibble: 8 × 2\n  region        num_countries\n  &lt;fct&gt;                 &lt;int&gt;\n1 Africa                   53\n2 Asia                     50\n3 Caribbean                17\n4 Europe                   39\n5 Latin Amer               20\n6 North America             2\n7 NorthAtlantic             1\n8 Oceania                  17\n\n\n\n\n6.4.2.4 Agrupamiento de datos con group_by()\n\nAgrupando los resultados respecto a valores de una columna.\n\n¿Cuál es la media del producto interior bruto per cápita del conjunto de países dentro de cada grupo?\n\n\n\nUN_tibble |&gt;\n  filter(!is.na(group)) |&gt;  # Quitamos NA's en grupo\n  group_by(group) |&gt;  # Pedimos el resumen agrupados por región\n  summarise(avg_ppgdp_group = mean(ppgdp, na.rm = TRUE)) # Filtramos NA's en ppgdp\n\n# A tibble: 3 × 2\n  group  avg_ppgdp_group\n  &lt;fct&gt;            &lt;dbl&gt;\n1 oecd            37761.\n2 other           11181.\n3 africa           2509.\n\n\n\nAgrupando los resultados respecto a valores de varias columnas.\n\n*¿Cuál es el promedio de fertilidad en los países de cada grupo y, dentro del mismo, según la región a la que pertenecen?\n\n\n\nUN_tibble |&gt;\n  filter(!is.na(group) & !is.na(region)) |&gt;  # Quitamos NA's en grupo\n  group_by(group, region) |&gt;  # Pedimos el resumen agrupados por grupo, región\n  summarise(avg_fertility = mean(fertility, na.rm = TRUE)) # Filtramos NA's en ppgdp\n\n`summarise()` has grouped output by 'group'. You can override using the\n`.groups` argument.\n\n\n# A tibble: 12 × 3\n# Groups:   group [3]\n   group  region        avg_fertility\n   &lt;fct&gt;  &lt;fct&gt;                 &lt;dbl&gt;\n 1 oecd   Asia                   2.12\n 2 oecd   Europe                 1.66\n 3 oecd   Latin Amer             2.03\n 4 oecd   North America          1.88\n 5 oecd   Oceania                2.04\n 6 other  Asia                   2.45\n 7 other  Caribbean              2.01\n 8 other  Europe                 1.50\n 9 other  Latin Amer             2.47\n10 other  NorthAtlantic          2.22\n11 other  Oceania                3.24\n12 africa Africa                 4.24\n\n\n\n\n6.4.2.5 Ordenación de datos con arrange()\n\nOrdenación de resultados por valores de una columna. Se hace por defecto de menor a mayor. Si queremos ordenar a la inversa usamos desc().\n\nObtén los 5 países de Europa que tienen mayor superficie urbanizada.\n\n\n\n# Después de la consulta, usamos head() para restringir el número de filas\n# En el siguiente capítulo presentamos top_n() para el mismo uso\nUN_tibble |&gt;\n  select(\"region\", \"ppgdp\") |&gt;\n  filter(region == \"Europe\") |&gt;\n  arrange(desc(ppgdp)) |&gt; \n  head(5)\n\n# A tibble: 5 × 2\n  region   ppgdp\n  &lt;fct&gt;    &lt;dbl&gt;\n1 Europe 105095.\n2 Europe  84589.\n3 Europe  68880.\n4 Europe  55830.\n5 Europe  48906.\n\n\n\nOrdenación de resultados por valores de varias columnas.\n\nOrdena los resultados de promedio de fertilidad de mujeres por grupo y región, de forma que primero aparezcan las regiones en orden alfabético y, para cada región, los grupos en orden alfabético.\n\n\n\nUN_tibble |&gt; \n  select(region, group, fertility) |&gt; \n  filter(!is.na(group) & !is.na(region)) |&gt; \n  group_by(group, region) |&gt; \n  summarise(avg_fertility = mean(fertility, na.rm = TRUE)) |&gt; \n  select(2,1,3) |&gt; # Volvemos a llamar a select para cambiar el orden de columnas\n  arrange(region, group) # Aquí ordenamos por región y dentro de cada una por grupo\n\n`summarise()` has grouped output by 'group'. You can override using the\n`.groups` argument.\n\n\n# A tibble: 12 × 3\n# Groups:   group [3]\n   region        group  avg_fertility\n   &lt;fct&gt;         &lt;fct&gt;          &lt;dbl&gt;\n 1 Africa        africa          4.24\n 2 Asia          oecd            2.12\n 3 Asia          other           2.45\n 4 Caribbean     other           2.01\n 5 Europe        oecd            1.66\n 6 Europe        other           1.50\n 7 Latin Amer    oecd            2.03\n 8 Latin Amer    other           2.47\n 9 North America oecd            1.88\n10 NorthAtlantic other           2.22\n11 Oceania       oecd            2.04\n12 Oceania       other           3.24\n\n\n\n\n6.4.2.6 Nuevas columnas con mutate()\nCuidado: si no almacenamos el resultado de la operación en una nueva variable, la nueva columna creada solo existirá durante la ejecución de la consulta que hemos escrito. Una vez devuelto el resultado, la nueva columna desaparece. Nunca se altera la tabla de datos original.\n\nCreación de una columna nueva a partir de operaciones sobre otra.\n\nTransformar todos los valores de la columna ppgdp, calculando su logaritmo natural..\n\n\n\n# Transformar el valor de `ppgdp con log()\nUN_tibble |&gt; \n  mutate(log_ppgdp = log(ppgdp)) |&gt; \n  head()\n\n# A tibble: 6 × 8\n  region    group  fertility  ppgdp lifeExpF pctUrban infantMortality log_ppgdp\n  &lt;fct&gt;     &lt;fct&gt;      &lt;dbl&gt;  &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt;           &lt;dbl&gt;     &lt;dbl&gt;\n1 Asia      other       5.97   499      49.5       23           125.       6.21\n2 Europe    other       1.52  3677.     80.4       53            16.6      8.21\n3 Africa    africa      2.14  4473      75         67            21.5      8.41\n4 &lt;NA&gt;      &lt;NA&gt;       NA       NA      NA         NA            11.3     NA   \n5 Africa    africa      5.14  4322.     53.2       59            96.2      8.37\n6 Caribbean other       2    13750.     81.1      100            NA        9.53\n\n\n\nCreación de una columna nueva combinando valores de varias columnas.\n\nCalcular una nueva columna como el cociente entre mortalidad infantil y fertilidad de las mujeres para cada ubicación.\n\n\n\nUN_tibble |&gt; \n  mutate(mort_by_fert = infantMortality/fertility) |&gt; \n  head()\n\n# A tibble: 6 × 8\n  region   group fertility  ppgdp lifeExpF pctUrban infantMortality mort_by_fert\n  &lt;fct&gt;    &lt;fct&gt;     &lt;dbl&gt;  &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt;           &lt;dbl&gt;        &lt;dbl&gt;\n1 Asia     other      5.97   499      49.5       23           125.          20.9\n2 Europe   other      1.52  3677.     80.4       53            16.6         10.9\n3 Africa   afri…      2.14  4473      75         67            21.5         10.0\n4 &lt;NA&gt;     &lt;NA&gt;      NA       NA      NA         NA            11.3         NA  \n5 Africa   afri…      5.14  4322.     53.2       59            96.2         18.7\n6 Caribbe… other      2    13750.     81.1      100            NA           NA  \n\n\n\n\n6.4.2.7 Commbinación de tablas con inner_join()\nPara esta sección, vamos a crear una segunda tabla de datos ficticios, incluyendo una variable descriptiva más para cada región. Para ello, vamos a usar la función tribble() (c.f. https://tibble.tidyverse.org/).\n\n# Estimaciones: https://www.worldometers.info/world-population/population-by-region/\nUN2 &lt;- tribble (\n  ~region, ~population, ~area,\n  \"Africa\",     1308064195, 29648481,\n  \"Asia\", 4601371198, 31033131,\n  \"Caribbean\", 48000000, 1139000,\n  \"Europe\", 747182751, 22134900,\n  \"Latin Amer\", 600120957, 19000378,\n  \"North America\", 360600964, 17651660,\n  \"NorthAtlantic\", 6000000, 1000000,\n  \"Oceania\", 42128035, 8486460\n)\nUN2$region = factor(UN2$region)  # Convertir region a factor\n\n\nCombinación de dos tablas según los valores comunes de una columna en cada tabla.\n\nCalcula el área total (en km^2) urbanizada en cada región..\n\n\n\n# Hay que conectar las filas de las tablas UN y UN2 según el valor de su región.\n# Una vez tenemos la fila con todos los datos, calculamos el producto del\n# porcentaje de suelo urbanizado y la superficie total.\n# Como los nombres de fila del data.frame original son en principio ignorados\n# por un objeto tibble, existen funciones que permiten recuperarlos:\n# https://tibble.tidyverse.org/reference/rownames.html.\n# Aquí usamos `rownames_to_column()`\n\nUN_tibble |&gt; \n  rownames_to_column(var=\"location\") |&gt; \n  select(\"location\",\"region\", \"pctUrban\") |&gt; \n  inner_join(UN2, by=\"region\") |&gt; \n  mutate(urban_km2 = pctUrban/100 * area)\n\n# A tibble: 199 × 6\n   location    region     pctUrban population     area urban_km2\n   &lt;chr&gt;       &lt;fct&gt;         &lt;dbl&gt;      &lt;dbl&gt;    &lt;dbl&gt;     &lt;dbl&gt;\n 1 Afghanistan Asia             23 4601371198 31033131  7137620.\n 2 Albania     Europe           53  747182751 22134900 11731497 \n 3 Algeria     Africa           67 1308064195 29648481 19864482.\n 4 Angola      Africa           59 1308064195 29648481 17492604.\n 5 Anguilla    Caribbean       100   48000000  1139000  1139000 \n 6 Argentina   Latin Amer       93  600120957 19000378 17670352.\n 7 Armenia     Asia             64 4601371198 31033131 19861204.\n 8 Aruba       Caribbean        47   48000000  1139000   535330 \n 9 Australia   Oceania          89   42128035  8486460  7552949.\n10 Austria     Europe           68  747182751 22134900 15051732 \n# ℹ 189 more rows\n\n  #rmarkdown::paged_table(options = list(rows.print = 15))\n\n\n\n\n\n\n\n\nInfo: Dónde hacer operaciones join\n\n\n\nA pesar de que, como acabamos de ver,\ndplyr\npermite\n         realizar operaciones de tipo join para unir dos o más tablas, si los\n         datos están almacenamos en una base de datos relacional casi siempre\n         será más eficiente que dejemos que sea la base de datos la que realice\n         este tipo de operaciones.\n\nÚnicamente cuando ya nos han pasado los datos en formato data.frame (o\n         tibble), o bien cuando los leemos directamente de un archivo CSV, o de\n         una API en formato JSON, tiene sentido que implementemos estas operaciones\n         en nuestro código de R.\n\n\n\n\n\n\n\n\nCodd, E. F. (1990). The relational model for database management: version 2. Addison-Wesley Longman Publishing Co., Inc.\n\n\nKuhn, M., & Johnson, K. (2013). Applied Predictive Modeling. Springer New York. https://books.google.es/books?id=xYRDAAAAQBAJ\n\n\nWickham, H. (2014). Tidy Data. Journal of Statistical Software, Articles, 59(10), 1-23. https://doi.org/10.18637/jss.v059.i10\n\n\nWickham, H., Cetinkaya-Rundel, M., & Grolemund, G. (2023). R for Data Science: Import, Tidy, Transform, Visualize, and Model Data (2.ª ed.). O’Reilly Media. https://r4ds.hadley.nz/",
    "crumbs": [
      "El lenguaje R",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Tidy data</span>"
    ]
  },
  {
    "objectID": "06-tidy-data.html#footnotes",
    "href": "06-tidy-data.html#footnotes",
    "title": "6  Tidy data",
    "section": "",
    "text": "http://www.cookbook-r.com/Manipulating_data/Converting_data_between_wide_and_long_format/↩︎",
    "crumbs": [
      "El lenguaje R",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Tidy data</span>"
    ]
  },
  {
    "objectID": "07-data-in-out.html",
    "href": "07-data-in-out.html",
    "title": "7  Importación y exportación de datos",
    "section": "",
    "text": "7.1 Importación de datos\nHasta ahora, nos hemos basado generalmente en datos que ya están previamente cargados y disponibles en paquetes de R para nuestros ejemplos. Sin embargo, lo habitual en un proyecto es que tengamos que leer los datos de algún tipo de fuente externa a R:\nNo es posible cubrir toda esta casuística en el tiempo de curso. Por ello, nos vamos a centrar en la lectura de datos CSV y la lectura de datos de Excel para cubrir dos ejemplos muy comunes de importanción de datos en R.",
    "crumbs": [
      "El lenguaje R",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Importación y exportación de datos</span>"
    ]
  },
  {
    "objectID": "07-data-in-out.html#importación-de-datos",
    "href": "07-data-in-out.html#importación-de-datos",
    "title": "7  Importación y exportación de datos",
    "section": "",
    "text": "Archivo textual: Los datos pueden estar almacenados en formato libre, pero lo normal es que sigan una pauta para organizar su presentación, según algún formato estándar de representación de datos.\n\nCSV (Comma Separated Values): Los datos se escriben insertando una línea por cada fila de la tabla, y separando los valores de cada columna mediante comas. Los strings suelen ir delimitados por dobles comillas (“). Desgraciadamente, no existe una convención única sobre qué carácteres usar para delimitar strings o separar los valores de cada columna. A veces también se pueden usar puntos y coma, tabuladores, etc. Debemos informarnos sobre el formato empleado o descubrirlo nosotros, inspeccionando algunas líneas del archivo en crudo.\nJSON (JavaScript Object Notation): Es un formato que se ha popularizado bastante, porque lo suelen emplear muchos servicios y APIs web que exportan datos. Es bastante compacto y permite representar arrays y listas arbitrarias de objetos. También se puede usar este formato para guardar datos en archivos de texto.\n\nBase de datos (normalmente relacional): Guarda los datos en tablas similares a un data.frame (o tibble). R proporciona paquetes que permiten conectarnos a muchos tipos de bases de datos para realizar consultas y recuperar información. Normalmente, el resultado que la base de datos envía como respuesta a nuestra consulta se formatea automáticamente como un data.frame (lo hacen las propias bibliotecas conectoras de R).\nFormatos binarios (Excel, OpenOffice, LibreOffice, etc.): En ocasiones los datos se han creado previamente en un programa ofimático o de otro tipo, y tenemos que importarlos en R. El caso habitual es Excel que, hoy en día, continúa siendo una herramienta muy habitual en gestión y cálculo de datos.\n\n\n\n7.1.1 Importar datos de archivos de texto: CSV\nPara la mayoría de formatos de almacenamiento en archivos de texto, las funciones del paquete readr, que también forma parte del núcleo básico de tidyverse, son una buena alternativa para cargar de manera fiable nuestros datos en R.\nPodemos ejecutar en consola el siguiente comando, para mostrar una lista de todas las funciones incluidas en este paquete:\n\nhelp(package=\"readr\")\n\nTodas las funciones que comienzan por readr_ están pensadas para automatizar la lectura de datos de archivos textuales. Por desgracia, no existe un formato universal de representación de datos en CSV. Así que hay diferentes funciones para cada caso. Presentamos en la tabla Tabla 7.1 las principales.\n\n\n\nTabla 7.1: Funciones típicas de lectura de datos en formato CSV y similares.\n\n\n\n\n\n\n\n\n\nNombre función\nDescripción\n\n\n\n\nread_delim()\nFunción genérica, hay que especificar delimitador.\n\n\nread_csv()\nAsume delimitador es “,” y que “.” separa decimales.\n\n\nread_csv2()\nAsume delimitador es “;” y que “,” separa decimales.\n\n\nread_tsv()\nAsume delimitador es “\\t” (tabulador)\n\n\n\n\n\n\nVeamos un ejemplo que muestre la potencia de estas funciones. En el subdirectorio data del directorio de este manual, tenemos el archivo ACMETelephoneABT.csv. Este archivo proviene de un ejemplo de un conocido (y muy recomendable) libro de introducción a la ciencia de datos y el aprendizaje máquina (Kelleher et al., 2015).\nAhora comprobamos lo fácil que es leer los datos, en una sola línea de código R:\n\nACMETelephoneABT &lt;- read_csv(\"data/ACMETelephoneABT.csv\", na = c(\"\", \" \"))\n\nRows: 10000 Columns: 33\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr  (5): occupation, regionType, marriageStatus, creditRating, creditCard\ndbl (24): customer, age, income, numHandsets, handsetAge, currentHandsetPric...\nlgl  (4): children, smartPhone, homeOwner, churn\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\nclass(ACMETelephoneABT)  # Comprobamos clase del objeto\n\n[1] \"spec_tbl_df\" \"tbl_df\"      \"tbl\"         \"data.frame\" \n\ndim(ACMETelephoneABT)  # Dimensiones de la tabla\n\n[1] 10000    33\n\nhead(ACMETelephoneABT, n = 75) # 5 páginas de tabla de resultados\n\n# A tibble: 75 × 33\n   customer   age occupation   regionType marriageStatus children income\n      &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;        &lt;chr&gt;      &lt;chr&gt;          &lt;lgl&gt;     &lt;dbl&gt;\n 1  1000004    26 crafts       town       yes            TRUE          6\n 2  1000012    36 &lt;NA&gt;         &lt;NA&gt;       yes            TRUE          9\n 3  1000034    74 professional town       yes            FALSE         7\n 4  1000063    30 &lt;NA&gt;         suburban   no             FALSE         6\n 5  1000085    32 &lt;NA&gt;         town       yes            FALSE         7\n 6  1000100    40 homemaker    rural      yes            TRUE          7\n 7  1000121    52 &lt;NA&gt;         &lt;NA&gt;       no             FALSE         3\n 8  1000135    32 clerical     &lt;NA&gt;       yes            FALSE         5\n 9  1000143    40 &lt;NA&gt;         &lt;NA&gt;       unknown        FALSE         5\n10  1000164    42 &lt;NA&gt;         &lt;NA&gt;       yes            TRUE          4\n# ℹ 65 more rows\n# ℹ 26 more variables: numHandsets &lt;dbl&gt;, handsetAge &lt;dbl&gt;, smartPhone &lt;lgl&gt;,\n#   currentHandsetPrice &lt;dbl&gt;, creditRating &lt;chr&gt;, homeOwner &lt;lgl&gt;,\n#   creditCard &lt;chr&gt;, avgBill &lt;dbl&gt;, avgMins &lt;dbl&gt;, avgrecurringCharge &lt;dbl&gt;,\n#   avgOverBundleMins &lt;dbl&gt;, avgRoamCalls &lt;dbl&gt;, callMinutesChangePct &lt;dbl&gt;,\n#   billAmountChangePct &lt;dbl&gt;, avgReceivedMins &lt;dbl&gt;, avgOutCalls &lt;dbl&gt;,\n#   avgInCalls &lt;dbl&gt;, peakOffPeakRatio &lt;dbl&gt;, …\n\n\nConviene resaltar algunos puntos importantes:\n\nLa función read_csv() utilizada sin argumentos (como en este ejemplo) intenta usar heurísticos sencillos para adivinar el tipo de datos adecuado para formatear los valores de cada columna. Si no ocultamos los avisos, la función nos indica (como vemos arriba en este documento) qué formatos ha utilizado para leer cada una de las columnas. Conviene no ocultar esta información, ya que muchos errores en preparación y limpieza de datos provienen de confusiones con el tipo de datos asignado a una columna.\nLos valores de tipo string (en tibble marcados como &lt;chr&gt;) no se convierten a factores de forma automática, sino que se dejan como cadena de caracteres. Por tanto, si deseamos que se considere a los valores de alguna columna explícitamente como factor, habrá que especificarlo en el momento de leer los datos, o bien convertirlo explícitamente más adelante. Será más conveniente elegir una u otra opción dependiendo de si tenemos que limpiar intensamente los datos de esa columna o ya vienen en buen estado.\nEs imprtante especificar qué convención se usa para indicar los datos faltantes en el archivo. Suele ser arbitrario (y, por desgracia, a veces caótico), obligándonos a limpiar los datos siguiendo el método de prueba y error. Por defecto, la función considera el argumento na = c(\"\", \"NA\"), es decir un stríng vacío o el string \"NA\" marcan un dato faltante en la tabla. En nuestro caso, bien porque nos han avisado o por una inspección preliminar del contenido del archivo sabemos que, en su lugar, los datos faltantes se marcan con string vacío o con espacio en blanco (” “).\n\nCon esto hemos leído de forma aparentemente sencilla los datos de un archivo CSV. En este caso, hemos usado read_csv() porque los autores son británicos, y por tanto usan la convención de separar en cada fila los valores de cada columna mediante “,” y usar “.” como caracter para delimitar la parte decimal de un número.\nSin embargo, más adelante volveremos a tratar este dataset y comprobaremos que, como suele ser habitual en un caso real, la lectura inicial de datos no es más que el primer paso de un proceso de limpieza de datos, que suele consumir en torno a un 80% del tiempo de trabajo en el proyecto para el científico de datos.\nPor último, es importante resaltar que en RStudio podemos también usar de forma equivalente una interfaz gráfica para diseñar interactivamente el comando de lectura del archivo CSV que vamos a ejecutar. Para ello, en el panel multipropósito (normalmente arriba a la derecha), pinchamos en la pestaña “Environment” y pulsamos el botón “Import Dataset”. Después, seleccionamos la opción “From Text (readr)…” y aparece un cuadro de diálogo. En la parte superior, pinchando en el botón “Browse” podemos navegar el disco para seleccionar el archivo a cargar.\nAl seleccionarlo, en el cuadro de diálogo aparece una previsualización del que será el resultado de la lectura una vez ejecutado el comando, que se va construyendo en la parte inferior derecha del cuadro diálogo. Este comando se ejecutará automáticamente en consola al confirmar el proceso, pulsando el botón “Import”. En la parte superior de las columnas, podemos pinchar en los títulos de columna para desplegar una larga lista con todos los tipos de datos disponibles para formatear dicha columna. Si elegimos un nuevo tipo de datos que no es el considerado por defecto por la función, el comando de lectura se actualiza automáticamente para formatear la columna según el nuevo tipo de dato elegido.\n\n\n7.1.2 Importar datos de archivos Excel\nImportar datos desde un archivo Excel, siempre que no contenga características especiales (macros, multicolumnas o multifilas, automatismos, etc.), es también facilmente abordable mediante el paquete readxl y la función read_excel() incluida en el mismo.\nEn este caso también se puede teclear el comando en consola (o en un script de R), o bien usar el cuadro diálogo interactivo para diseñar el comando de lectura del fichero de Excel. A esta segunda opción se accede también pulsando en la pestaña “Environment” del panel multipropósito el botón “Import Dataset”, y seleccionando “From Excel…”.\nEnviamos a los lectores interesados en probar un ejemplo de lectura de ficheros Excel a realizar el ejercicio guiado propuesto en el capítulo 4 del libro en línea “Modern Dive into R” (sec. 4.1.2).\n\n\n7.1.3 Otras herramientas de importación de datos\nEn este curso solo cubrimos los casos más típicos y sencillos de importación de datos. Sin embargo, este paso puede acarrear muchos quebraderos de cabeza a los científicos de datos que deben abordarlo. Especialmente difícil resulta la lectura rápida y eficiente de archivos muy largos, que pueden contener cientos de miles o decenas de millones de líneas (o incluso más), cada una representando una fila de la futura tabla con todos los valores para cada columna.\nPor este motivo, presentamos aquí un par de alternativas para que el lector que se enfrente en alguna ocasión a este reto tenga pistas sobre dónde empezar a documentarse para resolver el problema:\n\nEl paquete vroom (cuidado, no confundir con broom), es una alternativa reciente para lectura/escritura de datos extremadamente rápida y eficiente en R. Referimos al lector interesado a la viñeta de introducción a vroom para más detalles. Entre las funciones más resaltables tenemos:\n\nLectura automatizada de múltiples archivos.\nLectura de archivos comprimidos.\nLectura de archivos en ubicaciones remotas (con una URL).\n\nOtro proyecto que merece la pena destacar es Apache Arrow, que aspira a convertirse en el formato universal, independiente de plataforma para representación y serialización de datos en memoria. Cuenta con paquetes y librerías de enlace en muchos lenguajes de programación, incluido el paquete arrow en R. Su gran ventaja es que se emplea un formato universal de representación de datos extremadamente eficiente, que se mantiene inalterado con independencia del lenguaje de programación o plataforma de ejecución que empleemos.\n\n\n\n\n\nKelleher, J. D., Namee, B. M., & D’Arcy, A. (2015). Fundamentals of Machine Learning for Predictive Data Analytics: Algorithms, Worked Examples, and Case Studies. MIT Press Ltd.",
    "crumbs": [
      "El lenguaje R",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Importación y exportación de datos</span>"
    ]
  },
  {
    "objectID": "08-EDA.html",
    "href": "08-EDA.html",
    "title": "8  Análisis exploratorio de datos",
    "section": "",
    "text": "8.1 Datos de ejemplo\nUtilizaremos ejemplos del paquete agriTutorial (Rodney Edmondson et al., 2020), que incluye conjuntos de datos y ejemplos de modelos sobre exprimentos en agricultura. También usaremos el paquete R agridat (Wright, 2024), que contiene conjuntos de datos provenientes de publicaciones relacionadas con la agricultura, incluyendo cultivos de campo, cultivos arbóreos o estudios con animales, entre otros.\nPaquete agriTutorial\nPaquete agridat",
    "crumbs": [
      "Ejemplo práctico",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Análisis exploratorio de datos</span>"
    ]
  },
  {
    "objectID": "08-EDA.html#datos-de-ejemplo",
    "href": "08-EDA.html#datos-de-ejemplo",
    "title": "8  Análisis exploratorio de datos",
    "section": "",
    "text": "greenrice: Datos de un experimento sobre absorción de nitrogeno (N), medido en g/maceta en un experimento de doble factor en invernadero (Gomez & Gomez, 1984). Se considera la duración del estrés hídrico (W) y el nivel de aplicación de nitrógeno. El experimento se llevó a cabo con cuatro niveles de estrés hídrico (0, 10, 20 y 40 días) como tratamientos de parcela principal (main-plot treatment) y cuatro dosis de nitrógeno (0, 90, 180 y 270 kg/ha) como tratamientos de subparcela (sub-plot treatment). Las parcelas principales se aleatorizaron en cuatro bloques completos (cada bloque incluye todos las posibles combinaciones de tratamientos).\nrice: Datos de un experimento con tres prácticas de gestión (minimum, optimum, intensive), cinco cantidades distintas de fertilizante de nitrógeno (N) (0, 50, 80, 110, 140 kg/ha) y tres variedades de planta (V1, V2, V3) (Gomez & Gomez, 1984). El experimento sigue un diseño de parcelas divididas (split-plot design), donde la variedad de planta y el tipo de gestión son factores de tratamiento cualitativos y la cantidad de fertilizante de nitrógeno es un factor de tratamiento cuantitativo.\n\n\n\nnass.barley, nass.corn, nass.rice, nass.soybean y nass.wheat: Cinco conjunto de datos con valores de producción y superficie (en acres) cosechados en cada estado de EE.UU. para los cultivos agrícolas más importantes en este país, entre aproximadamente el año 1900 y el 2011. [Fuente: United States Department of Agriculture, National Agricultural Statistics Service. https://quickstats.nass.usda.gov/]",
    "crumbs": [
      "Ejemplo práctico",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Análisis exploratorio de datos</span>"
    ]
  },
  {
    "objectID": "08-EDA.html#carga-de-datos-y-esquema-tipos-de-datos",
    "href": "08-EDA.html#carga-de-datos-y-esquema-tipos-de-datos",
    "title": "8  Análisis exploratorio de datos",
    "section": "8.2 Carga de datos y esquema (tipos de datos)",
    "text": "8.2 Carga de datos y esquema (tipos de datos)\nLos conjuntos de datos de ejemplo ya se encuentran disponibles en cada uno de los paquetes mencionados. Sin embargo, vamos a hacer una prueba para verificar cómo podemos escribir y leer datos en R, por ejemplo utilizando un fichero CSV (muy común para almacenamiento de datos estructurados).\n\n\n\n\n\n\nTip\n\n\n\nPodemos utilizar la función write.csv() para escribir datos en un fichero en formato CSV que almacenemos en una ubicación de nuestro disco.\n\n\n\nlibrary(agridat)\nlibrary(agriTutorial)\n# Carga de datos en memoria\ndata(\"nass.corn\")\ndata(\"nass.corn\")\ndata(\"greenrice\")\ndata(\"rice\")\n# Escritura de datos a un fichero CSV\nwrite.csv(nass.barley, \"data/nass_barley.csv\", row.names = F)\nwrite.csv(nass.corn, \"data/nass_corn.csv\", row.names = F)\nwrite.csv(greenrice, \"data/greenrice.csv\", row.names = F)\n\n\n\n\n\n\n\nTip\n\n\n\nPodemos utilizar la función read_csv() del paquete readr para leer datos de un fichero en formato CSV almacenado en una ubicación de nuestro disco.\nLa lectura de datos será más rápida si indicamos explícitamente el tipo de dato que almacena cada columna mediante la función cols() y utilizando las funciones que denotan cada tipo de datos específico: col_integer(), col_character(), col_double(), etc.).\n\n\n\nlibrary(readr)\nlibrary(tibble)\n# Leemos los datos de los ficheros CSV creados antes\nnass_barley &lt;- read_csv(\"data/nass_barley.csv\", col_types = cols(col_integer(), col_character(),\n                      col_double(), col_double()))\nnass_corn &lt;- read_csv(\"data/nass_corn.csv\", col_types = cols(col_integer(), col_character(),\n                      col_double(), col_double()))\ngreen_rice &lt;- read_csv(\"data/greenrice.csv\", col_types = cols(col_double(), col_integer(), \n                       col_integer(), col_integer(), col_integer()))\n\nUna vez que hemos cargado los datos de un paquete R o los hemos leído de un fichero, podemos imprimir en pantalla información acerca de la tabla de datos para comprobar, por ejemplo, que todas las columnas se han identificado correctamente y el tipo de dato de cada columna es correcto.\n\n\n\n\n\n\nTip\n\n\n\nLos datos en muchos paquetes R están en formato data.frame, menos potente que los objetos tibble creados mediante funciones como read_csv(). Podemos crear automáticamente un objeto tibble a partir de un data.frame con la función tibble():\nmy_tibble &lt;- tibble(greenrice)\n\n\n\n\n\n\n\n\nTip\n\n\n\nPara comprobar los metadatos de un tabla en formato tibble podemos usar la función str().\n\n\n\nstr(nass_barley)\n\nspc_tbl_ [4,839 × 4] (S3: spec_tbl_df/tbl_df/tbl/data.frame)\n $ year : int [1:4839] 1866 1866 1866 1866 1866 1866 1866 1866 1866 1866 ...\n $ state: chr [1:4839] \"Connecticut\" \"Illinois\" \"Indiana\" \"Iowa\" ...\n $ acres: num [1:4839] 1000 96000 11000 66000 2000 10000 34000 7000 21000 20000 ...\n $ yield: num [1:4839] 22.5 23.4 23 22 23 23.5 21.5 25.5 26 26 ...\n - attr(*, \"spec\")=\n  .. cols(\n  ..   year = col_integer(),\n  ..   state = col_character(),\n  ..   acres = col_double(),\n  ..   yield = col_double()\n  .. )\n - attr(*, \"problems\")=&lt;externalptr&gt;",
    "crumbs": [
      "Ejemplo práctico",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Análisis exploratorio de datos</span>"
    ]
  },
  {
    "objectID": "08-EDA.html#operaciones-básicas",
    "href": "08-EDA.html#operaciones-básicas",
    "title": "8  Análisis exploratorio de datos",
    "section": "8.3 Operaciones básicas",
    "text": "8.3 Operaciones básicas\n\nlibrary(dplyr) # Operaciones de selección y filtrado de datos\nlibrary(tidyr) # Operaciones de transformación y procesado de datos\n\n\n8.3.1 Operaciones de selección\nSelección de columnas\nPara seleccionar determinadas columnas (y todas sus filas) usamos la función select().\n\ngreen_rice_uptake &lt;- select(green_rice, Replicate, Main, uptake)\nstr(green_rice_uptake)\n\ntibble [64 × 3] (S3: tbl_df/tbl/data.frame)\n $ Replicate: int [1:64] 1 1 1 1 1 1 1 1 1 1 ...\n $ Main     : int [1:64] 1 1 1 1 2 2 2 2 3 3 ...\n $ uptake   : num [1:64] 1.033 0.506 0.692 0.254 0.154 ...\n\n\nFiltrado de filas\nPodemos añadir condiciones adicionales de filtrado (mediante expresiones booleanas) que se utilicen para recuperar sólo las filas de esa columna o columnas que cumplan cierta condición.\n\ncorn_MI &lt;- filter(nass_corn, state == \"Michigan\")\nhead(corn_MI)\n\n# A tibble: 6 × 4\n   year state     acres yield\n  &lt;int&gt; &lt;chr&gt;     &lt;dbl&gt; &lt;dbl&gt;\n1  1866 Michigan 480000  32  \n2  1867 Michigan 500000  36  \n3  1868 Michigan 560000  33  \n4  1869 Michigan 540000  28  \n5  1870 Michigan 570000  39  \n6  1871 Michigan 600000  33.5\n\n\nTambién se pueden imponer simultáneamente varias condiciones de filtrado. En ese caso, es común utilizar el operador %in%, para comprobar valores dentro de un conjunto finito de opciones válidas.\n\ncorn_pnw &lt;- filter(nass_corn, state %in% c(\"Idaho\", \"Oregon\", \"Washington\"))\nhead(corn_pnw)\n\n# A tibble: 6 × 4\n   year state  acres yield\n  &lt;int&gt; &lt;chr&gt;  &lt;dbl&gt; &lt;dbl&gt;\n1  1869 Oregon  3000  25  \n2  1870 Oregon  3000  23  \n3  1871 Oregon  4000  25  \n4  1872 Oregon  4000  26.5\n5  1873 Oregon  4000  26  \n6  1874 Oregon  4000  25  \n\n\nPor último, también se pueden usar valores obtenidos como resultado de otras operaciones. Por ejemplo, veamos cómo recuperar sólo las filas que tengan un valor de superficie menor que la mediana de esa variable.\n\ncorn_low_surf &lt;- filter(nass_corn, acres &lt; median(nass_corn$acres))\nhead(corn_low_surf)\n\n# A tibble: 6 × 4\n   year state        acres yield\n  &lt;int&gt; &lt;chr&gt;        &lt;dbl&gt; &lt;dbl&gt;\n1  1866 Arkansas    280000    18\n2  1866 California   42000    28\n3  1866 Connecticut  57000    34\n4  1866 Delaware    200000    23\n5  1866 Florida     125000     9\n6  1866 Kansas      217000    28\n\n\nFiltrado de columnas\n\ngreen_rice_W &lt;- select(green_rice, -uptake, -N)\nstr(green_rice_W)\n\ntibble [64 × 3] (S3: tbl_df/tbl/data.frame)\n $ W        : int [1:64] 10 10 10 10 40 40 40 40 0 0 ...\n $ Replicate: int [1:64] 1 1 1 1 1 1 1 1 1 1 ...\n $ Main     : int [1:64] 1 1 1 1 2 2 2 2 3 3 ...\n\n\nOrdenación de datos\nEs posible ordenar en función de los valores de una columna o de varias mediante la función arrange(). En el caso de que usemos varias, primero se ordena por los valores de la primera columna y, para cada uno de ellos, por los valores de la siguiente columna especificada.\n\nbarley_byState &lt;- arrange(nass_barley, state)\nhead(barley_byState)\n\n# A tibble: 6 × 4\n   year state   acres yield\n  &lt;int&gt; &lt;chr&gt;   &lt;dbl&gt; &lt;dbl&gt;\n1  1943 Alabama  5000  18  \n2  1944 Alabama  5000  20.5\n3  1945 Alabama  2000  20  \n4  1946 Alabama  2000  18  \n5  1947 Alabama  1000  18  \n6  1948 Alabama  2000  19  \n\n\n\nbarley_byYear_yield &lt;- arrange(nass_barley, year, yield)\nhead(barley_byYear_yield)\n\n# A tibble: 6 × 4\n   year state         acres yield\n  &lt;int&gt; &lt;chr&gt;         &lt;dbl&gt; &lt;dbl&gt;\n1  1866 Texas          3000  16  \n2  1866 Pennsylvania  30000  18.5\n3  1866 Missouri       9000  21  \n4  1866 Maine         34000  21.5\n5  1866 Iowa          66000  22  \n6  1866 New Hampshire  4000  22  \n\n\nPor defecto, la ordenación se hace en sentido ascendente para valores numéricos (de menor a mayor valor) y en orden alfabético para cadenas de caracteres (datos cualitativos).\nSi queremos invertir el orden de la operación de ordenación podemos usar la función desc().\n\nbarley_byYear_desc &lt;- arrange(nass_barley, desc(year),)\nhead(barley_byYear_desc)\n\n# A tibble: 6 × 4\n   year state       acres yield\n  &lt;int&gt; &lt;chr&gt;       &lt;dbl&gt; &lt;dbl&gt;\n1  2011 Alaska       4800  36.5\n2  2011 Arizona     64000 125  \n3  2011 California  75000  63  \n4  2011 Colorado    63000 126  \n5  2011 Delaware    32000  88  \n6  2011 Idaho      500000  93  \n\n\nSelección de filas\nLa función slice() nos permite seleccionar un conjunto de filas según su índice, teniendo en cuenta que la primera fila tiene el índice 1.\n\n# Recuperamos 90 observaciones, de la fila 11 a la 100\nbarley_10_100 &lt;- nass_barley |&gt;\n                 slice(11:100)\nnrow(barley_10_100)\n\n[1] 90\n\n\n\n\n\n\n\n\nTip\n\n\n\nLa función slice() viene acompañada de otras funciones de ayuda que implementan casos comunes: slice_head(), slice_tail(), slice_sample(), slice_min(), slice_max(). Para conocer más detalles consulta la página de documentación de slice().\n\n\n\n\n8.3.2 Transformación de datos\nDefinición de nuevas variables\nSe pueden definir nuevas columnas que representen variables adicionales mediante la función mutate(). Para cada nueva variable, especificamos el nombre de la columna y la operación a realizar para obtener cada valor de esa nueva columna. Se pueden utilizar los valores de otras columnas previas.\n\ncorn_high_surf &lt;- mutate(nass_corn, \n                    harvest_index = acres/yield,\n                    year_factor = as.factor(year),\n                    is_high = acres &gt; median(acres),\n                    crop = \"corn\", \n                    relative_yld = yield/mean(yield))\n\nhead(corn_high_surf)\n\n# A tibble: 6 × 9\n   year state   acres yield harvest_index year_factor is_high crop  relative_yld\n  &lt;int&gt; &lt;chr&gt;   &lt;dbl&gt; &lt;dbl&gt;         &lt;dbl&gt; &lt;fct&gt;       &lt;lgl&gt;   &lt;chr&gt;        &lt;dbl&gt;\n1  1866 Alaba… 1.05e6     9       116667. 1866        TRUE    corn         0.172\n2  1866 Arkan… 2.8 e5    18        15556. 1866        FALSE   corn         0.343\n3  1866 Calif… 4.20e4    28         1500  1866        FALSE   corn         0.534\n4  1866 Conne… 5.7 e4    34         1676. 1866        FALSE   corn         0.649\n5  1866 Delaw… 2   e5    23         8696. 1866        FALSE   corn         0.439\n6  1866 Flori… 1.25e5     9        13889. 1866        FALSE   corn         0.172\n\n\nRenombrado de columnas\nSe puede cambiar el nombre de una columna con la función rename(dataframe, newname = \"oldname\").\nSeparación de valores\nPuede ocurrir que los datos no cumplan los criterios de tidy data, por ejemplo, porque existan múltiples valores en una misma celda. Para este caso podemos usar varias funciones del paquete tidyr que operan sobre vectores de tipo caracter.\nPor otro lado, también podemos necesitar unir dos o más columnas, creando un valor único a partir del valor de origen de cada columna. Esto puede ser útil, por ejemplo, para usar esa nueva columna en la búsqueda de valores coincidentes entre dos conjuntos de datos. En ese caso podemos usar la función unite() (https://tidyr.tidyverse.org/reference/unite.html).",
    "crumbs": [
      "Ejemplo práctico",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Análisis exploratorio de datos</span>"
    ]
  },
  {
    "objectID": "08-EDA.html#resúmenes-estadísticos",
    "href": "08-EDA.html#resúmenes-estadísticos",
    "title": "8  Análisis exploratorio de datos",
    "section": "8.4 Resúmenes estadísticos",
    "text": "8.4 Resúmenes estadísticos\n\nLa función group_by() permite obtener resúmenes de datos agrupando por una variable categórica (o bien una cuantitativa que tratemos como categórica, por ejemplo año, mes, etc.).\nPor otro lado, la función summarise() suele aparecer detrás de un comando de agrupación como el anterior, para aplicar una función de resumen de datos (media, mediana, etc.) a todo el conjunto de datos o a cada uno de los grupos que hemos generado.\n\nLa utilización del operador integrado pipe (|&gt;) elimina la necesidad de utilizar muchos objetos/variables para guardar los resultados intermedios, quedando un código más limpio y fácil de interpretar.\nPor ejemplo, calculamos el promedio de producción anual de cebada en todos los estados.\n\nbarley_annual_mean &lt;- nass_barley |&gt;\n    group_by(year) |&gt;\n    summarise(mean_yield = mean(yield, na.rm = T))\nhead(barley_annual_mean)\n\n# A tibble: 6 × 2\n   year mean_yield\n  &lt;int&gt;      &lt;dbl&gt;\n1  1866       23.3\n2  1867       22.9\n3  1868       22.2\n4  1869       23.9\n5  1870       22.4\n6  1871       22.2\n\n\nPara el estudio con parcelas divididas del arroz en invernadero, podemos obtener la mediana de producción por cada tipo de estrategia de gestión en todas las combinaciones.\n\nrice_mean_yield &lt;- rice |&gt;\n  group_by(management) |&gt;\n  summarise(median_yield = median(yield, na.rm = T))\nhead(rice_mean_yield)\n\n# A tibble: 3 × 2\n  management median_yield\n  &lt;fct&gt;             &lt;dbl&gt;\n1 Minimum            5.78\n2 Optimum            6.36\n3 Intensive          7.25\n\n\nY ahora también tenemos en cuenta la replica experimental para desglosar aún más la mediana de la producción.\n\nrice_mean_yield_by_rep &lt;- rice |&gt;\n  group_by(management, Replicate) |&gt;\n  summarise(median_yield = median(yield, na.rm = T))\n\n`summarise()` has grouped output by 'management'. You can override using the\n`.groups` argument.\n\nhead(rice_mean_yield_by_rep)\n\n# A tibble: 6 × 3\n# Groups:   management [2]\n  management Replicate median_yield\n  &lt;fct&gt;      &lt;fct&gt;            &lt;dbl&gt;\n1 Minimum    R1                5.60\n2 Minimum    R2                5.99\n3 Minimum    R3                5.39\n4 Optimum    R1                6.40\n5 Optimum    R2                6.46\n6 Optimum    R3                5.90\n\n\n\n8.4.1 El paquete Hmisc\n\nlibrary(Hmisc)\nHmisc::html(describe(green_rice))\n\n\n\n\n\ngreen_rice Descriptives\ngreen_rice  5  Variables   64  Observations\n\nuptake\n        n  missing distinct     Info     Mean      Gmd      .05      .10      .25 \n       64        0       61        1   0.4582   0.3277  0.09815  0.10540  0.21400 \n      .50      .75      .90      .95 \n  0.45500  0.61450  0.83450  1.02910  \n\nlowest : 0.084 0.089 0.093 0.098 0.099 ,  highest: 1.007 1.033 1.034 1.089 1.297\n\nW\n\n \n nmissingdistinctInfoMeanGmd\n 64040.93817.516.51\n \n\n Value         0   10   20   40\n Frequency    16   16   16   16\n Proportion 0.25 0.25 0.25 0.25 \n\n\nFor the frequency table, variable is rounded to the nearest 0\n\nN\n\n \n nmissingdistinctInfoMeanGmd\n 64040.938135114.3\n \n\n Value         0   90  180  270\n Frequency    16   16   16   16\n Proportion 0.25 0.25 0.25 0.25 \n\n\nFor the frequency table, variable is rounded to the nearest 0\n\nReplicate\n\n \n nmissingdistinctInfoMeanGmd\n 64040.9382.51.27\n \n\n Value         1    2    3    4\n Frequency    16   16   16   16\n Proportion 0.25 0.25 0.25 0.25 \n\n\nFor the frequency table, variable is rounded to the nearest 0\n\nMain\n\n \n nmissingdistinctInfoMeanGmd\n 64040.9382.51.27\n \n\n Value         1    2    3    4\n Frequency    16   16   16   16\n Proportion 0.25 0.25 0.25 0.25 \n\n\nFor the frequency table, variable is rounded to the nearest 0\n\n\n\n\n\n\n\nGomez, K. A., & Gomez, A. A. (1984). Statistical Procedures for Agricultural Research. John Wiley & Sons.\n\n\nRodney Edmondson, Hans-Peter Piepho, & Muhammad Yaseen. (2020). agriTutorial: Tutorial Analysis of Some Agricultural Experiments .\n\n\nTukey, J. W. (1977). Exploratory Data Analysis (1.ª ed.). Addison-Wesley Pub.\n\n\nWright, K. (2024). agridat: Agricultural Datasets. https://CRAN.R-project.org/package=agridat",
    "crumbs": [
      "Ejemplo práctico",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Análisis exploratorio de datos</span>"
    ]
  },
  {
    "objectID": "09-visual.html",
    "href": "09-visual.html",
    "title": "9  Creación de gráficos",
    "section": "",
    "text": "9.1 Gráficos exploratorios\nEn un taller posterior trataremos más en profundidad cómo generar gráficos de calidad con R. En este punto, sólo mostramos unos ejemplos para ilustrar algunas de las posibilidades básicas de representación gráfica de datos.\nEvolución de la producción media anual de cebada\nlibrary(readr)\nlibrary(dplyr)\nlibrary(ggplot2)\nlibrary(ggpmisc)\n\nnass_barley &lt;- read_csv(\"data/nass_barley.csv\", col_types = cols(col_integer(), col_character(),\n  col_double(), col_double()))\n\nbarley_annual_mean &lt;- nass_barley |&gt;\n  group_by(year) |&gt;\n  summarise(mean_yield = mean(yield, na.rm = T))\nhead(barley_annual_mean)\n\n# A tibble: 6 × 2\n   year mean_yield\n  &lt;int&gt;      &lt;dbl&gt;\n1  1866       23.3\n2  1867       22.9\n3  1868       22.2\n4  1869       23.9\n5  1870       22.4\n6  1871       22.2\n\nggplot(data = barley_annual_mean, aes(x = year, y = mean_yield)) +\n  geom_line(color = \"navy\") +\n  stat_valleys(geom = \"point\", span = 11, color = \"red\", size = 2) +\n  stat_valleys(geom = \"label\", span = 11, color = \"red\", angle = 0,\n               hjust = -0.1) +\n  stat_valleys(geom = \"rug\", span = 11, color = \"red\", sides = \"b\") +\n  ggtitle(\"Evolución de la media de producción anual de cebada (EE.UU.)\")\n\n\n\n\n\n\n\nFigura 9.1: Evolución de la media de producción anual de cebada en EE.UU.\nDistribución de valores de producción anual por estado a partir del año 2000\nbarley_yield_2000 &lt;- nass_barley |&gt;\n  filter(year &gt;= 2000)\n\nggplot(data = barley_yield_2000, aes(x = year, y = yield, group = year, fill = year)) +\n  geom_boxplot(alpha = .5) +\n  ggtitle(\"Producción anual de cebada desde el año 2000 (EE.UU.)\")\n\n\n\n\n\n\n\nFigura 9.2: Producción anual de cebada desde el año 2000 (EE.UU.)",
    "crumbs": [
      "Ejemplo práctico",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Creación de gráficos</span>"
    ]
  },
  {
    "objectID": "10-models.html",
    "href": "10-models.html",
    "title": "10  Modelos con R",
    "section": "",
    "text": "10.1 Ejemplos de experimentos en Ciencias Agrícolas",
    "crumbs": [
      "Ejemplo práctico",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Modelos con R</span>"
    ]
  },
  {
    "objectID": "10-models.html#ejemplos-de-experimentos-en-ciencias-agrícolas",
    "href": "10-models.html#ejemplos-de-experimentos-en-ciencias-agrícolas",
    "title": "10  Modelos con R",
    "section": "",
    "text": "Tutorial Analysis of Some Agricultural Experiments.",
    "crumbs": [
      "Ejemplo práctico",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Modelos con R</span>"
    ]
  },
  {
    "objectID": "11-add-resources.html",
    "href": "11-add-resources.html",
    "title": "11  Recursos adicionales",
    "section": "",
    "text": "11.1 Recursos para Ciencias Agrícolas y Medioambientales",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Recursos adicionales</span>"
    ]
  },
  {
    "objectID": "11-add-resources.html#recursos-para-ciencias-agrícolas-y-medioambientales",
    "href": "11-add-resources.html#recursos-para-ciencias-agrícolas-y-medioambientales",
    "title": "11  Recursos adicionales",
    "section": "",
    "text": "R Packages for Agricultural Research (J. Piaskowski, Univ. of Idaho, 2024).\nData Analysis and Visualization in R for Ecologist (Data Carpentry).\nStatistical Analysis of Agricultural Experiments using R (A. Kniss y J. Streibig, 2019).",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Recursos adicionales</span>"
    ]
  },
  {
    "objectID": "11-add-resources.html#recursos-de-aprendizaje-generales",
    "href": "11-add-resources.html#recursos-de-aprendizaje-generales",
    "title": "11  Recursos adicionales",
    "section": "11.2 Recursos de aprendizaje generales",
    "text": "11.2 Recursos de aprendizaje generales\n\nFinding Your Way to R: Tutorial creado por el equipo educativo de Posit.\nLearn the tidyverse: Recursos para profundizar en el análisis de datos con R y los paquetes del Tidyverse.\nStatistical Inference via Data Science (C. Ismay y A.Y. Kim, 2024): Un libro estupendo para repasar conceptos estadísticos con una aproximación práctica, utilizando R y los paquetes del Tidyverse.\n\n\n11.2.1 Ejercicios y referencias sobre tidyverse\nLlegados a este punto, lo más importante es realizar la mayor cantidad posible de ejercicios y ejemplos para afianzar nuestro conocimiento de las funciones de los paquetes dplyr y tidyr. Sobre todo si tenemos todavía poca experiencia en programación (y aunque sí la tengamos, también), es importante tener mucha paciencia tanto con el propio lenguaje como con nosotros mismos.\ndplyr define una serie de operaciones para manipulación y consulta de datos que no son arbitrarias. Llevan definidas desde hace décadas, cuando expertos en bases de datos pensaron en la forma de organizar la información de manera más eficiente y cómo recuperarla y modificarla posteriormente.\nPor tanto, es importante no desesperarse y poco a poco ir habituándose a las funciones existentes y a construir consultas con estas piezas básicas.\nRecomendamos a continuación varias fuentes en las que se pueden encontrar muchos ejemplos adicionales y ejercicios para practicar:\n\nLa versión online del libro R for Data Science de H. Wikcham (Wickham et al., 2023) incluye en el capítulo 5 más ejemplos de estas mismas operaciones, utilizando datos del paquete nycflights13.\nLos materiales en línea del curso Stat545 (https://stat545.com/), creado por J. Bryan contienen varios capítulos relevantes para repasar y practicar. Varios de estos capítulos también proponen ejercicios adicionales para resolver:\n\n\nEl capítulo 6 es una introducción a las operaciones básicas con dplyr.\nEl capítulo 7 amplía con más ejemplos la explicación de las funciones que solo involucran a una tabla.\nEl capítulo 14 se muestra como ampliar una tabla añadiendo más filas o más columnas procedentes de otras tablas.\nEl capítulo 15 amplía las operaciones join, explicando gráficamente y de forma clara cómo se combinan las tablas con cada operación y el resultado final.\n\n\nEl capítulo 3 del libro Modern Dive into R de C. Ismay y A.Y. Kim, contiene más ejemplos y explicaciones gráficas para entender todas estas operaciones.",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Recursos adicionales</span>"
    ]
  },
  {
    "objectID": "11-add-resources.html#creación-de-gráficos-en-r",
    "href": "11-add-resources.html#creación-de-gráficos-en-r",
    "title": "11  Recursos adicionales",
    "section": "11.3 Creación de gráficos en R",
    "text": "11.3 Creación de gráficos en R\n\nThe R Graph Gallery: Ofrece cientos de ejemplos de construcción de gráficos en R, algunos muy sofisticados.\nLibro Data Visualization: A practical introduction (K. Healy, Duke Univ., 2018): Aunque el código puede haber quedado algo desfasado por la evolución de los paquetes software en R, sigue siendo la fuente de referencia principal sobre creación de gráficos (en general) para visualización de datos.",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Recursos adicionales</span>"
    ]
  },
  {
    "objectID": "11-add-resources.html#modelos-estadísticos-y-aprendizaje-automático",
    "href": "11-add-resources.html#modelos-estadísticos-y-aprendizaje-automático",
    "title": "11  Recursos adicionales",
    "section": "11.4 Modelos estadísticos y aprendizaje automático",
    "text": "11.4 Modelos estadísticos y aprendizaje automático\n\n11.4.1 Tidymodels\n\nTidymodels: Se trata de un framework para trabajar con modelos estadísticos siguiendo los principios de trabajo y organización del Tidyverse. Los principales paquetes se encuentran reunidos en un solo metapaquete denominado tidymodels, que podemos instalar directamente para probar toda la suite de herramientas que incluye:\n\n\ninstall.packages(\"tidymodels\")\n\n\nGetting started with Tidymodels.\nLearn Tidymodels: Colección de tutoriales sobre ajuste de modelos con Tidymodels.\n\n\n\n11.4.2 mlr3\nEl paquete mlr3 (Lang et al., 2019) es una alternativa menos conocida pero muy potente para implementar modelos de aprendizaje automático en R.\n\nmlr3 website\n\nEsta versión ha sido rediseñada para favorecer la claridad del código y su modularidad, separando otras funciones no principales en muchos paquetes complementarios que también forman un ecosistema alrededor de mlr3.",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Recursos adicionales</span>"
    ]
  },
  {
    "objectID": "11-add-resources.html#bioconductor",
    "href": "11-add-resources.html#bioconductor",
    "title": "11  Recursos adicionales",
    "section": "11.5 Bioconductor",
    "text": "11.5 Bioconductor\nLa lista de recursos adicionales no quedaría completa sin mencionar el que, quizá, es uno de los proyectos más importantes dentro del universo R: Bioconductor (Huber et al., 2015). Se trata de un enorme ecosistema de paquetes (más de 3.000) que incluyen numerosas herramientas para Bioinformática, datos experimentales y automatización de flujos de trabajo.\n\nAbout Bioconductor.\n\n\n\n\n\nHuber, W., Carey, V. J., Gentleman, R., Anders, S., Carlson, M., Carvalho, B. S., Bravo, H. C., Davis, S., Gatto, L., Girke, T., Gottardo, R., Hahne, F., Hansen, K. D., Irizarry, R. A., Lawrence, M., Love, M. I., MacDonald, J., Obenchain, V., Ole’s, A. K., … Morgan, M. (2015). Orchestrating high-throughput genomic analysis with Bioconductor. Nature Methods, 12(2), 115-121. http://www.nature.com/nmeth/journal/v12/n2/full/nmeth.3252.html\n\n\nLang, M., Binder, M., Richter, J., Schratz, P., Pfisterer, F., Coors, S., Au, Q., Casalicchio, G., Kotthoff, L., & Bischl, B. (2019). mlr3: A modern object-oriented machine learning framework in R. Journal of Open Source Software. https://doi.org/10.21105/joss.01903\n\n\nWickham, H., Cetinkaya-Rundel, M., & Grolemund, G. (2023). R for Data Science: Import, Tidy, Transform, Visualize, and Model Data (2.ª ed.). O’Reilly Media. https://r4ds.hadley.nz/",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Recursos adicionales</span>"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "Referencias",
    "section": "",
    "text": "Codd, E. F. (1990). The relational model for database management:\nVersion 2. Addison-Wesley Longman Publishing Co., Inc.\n\n\nGomez, K. A., & Gomez, A. A. (1984). Statistical Procedures for Agricultural\nResearch. John Wiley & Sons.\n\n\nHuber, W., Carey, V. J., Gentleman, R., Anders, S., Carlson, M.,\nCarvalho, B. S., Bravo, H. C., Davis, S., Gatto, L., Girke, T.,\nGottardo, R., Hahne, F., Hansen, K. D., Irizarry, R. A., Lawrence, M.,\nLove, M. I., MacDonald, J., Obenchain, V., Ole’s, A. K., … Morgan, M.\n(2015). Orchestrating high-throughput genomic analysis with\nBioconductor. Nature Methods, 12(2),\n115–121. http://www.nature.com/nmeth/journal/v12/n2/full/nmeth.3252.html\n\n\nKelleher, J. D., Namee, B. M., & D’Arcy, A. (2015). Fundamentals\nof Machine Learning for\nPredictive Data Analytics:\nAlgorithms, Worked Examples, and\nCase Studies. MIT Press Ltd.\n\n\nKuhn, M., & Johnson, K. (2013). Applied Predictive\nModeling. Springer New York. https://books.google.es/books?id=xYRDAAAAQBAJ\n\n\nLang, M., Binder, M., Richter, J., Schratz, P., Pfisterer, F., Coors,\nS., Au, Q., Casalicchio, G., Kotthoff, L., & Bischl, B. (2019).\nmlr3: A modern object-oriented machine\nlearning framework in R. Journal of Open Source\nSoftware. https://doi.org/10.21105/joss.01903\n\n\nRodney Edmondson, Hans-Peter Piepho, & Muhammad Yaseen. (2020).\nagriTutorial: Tutorial Analysis of Some\nAgricultural Experiments .\n\n\nTukey, J. W. (1977). Exploratory data analysis (1st ed.).\nAddison-Wesley Pub.\n\n\nWickham, H. (2014). Tidy Data. Journal of Statistical\nSoftware, Articles, 59(10), 1–23. https://doi.org/10.18637/jss.v059.i10\n\n\nWickham, H., Cetinkaya-Rundel, M., & Grolemund, G. (2023). R for Data Science: Import, Tidy, Transform, Visualize,\nand Model Data (2nd ed.). O’Reilly Media. https://r4ds.hadley.nz/\n\n\nWright, K. (2024). agridat: Agricultural\nDatasets. https://CRAN.R-project.org/package=agridat",
    "crumbs": [
      "Referencias"
    ]
  },
  {
    "objectID": "A-command-ref.html",
    "href": "A-command-ref.html",
    "title": "Apéndice A — Comandos de utilidad",
    "section": "",
    "text": "A.1 R base",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Comandos de utilidad</span>"
    ]
  },
  {
    "objectID": "A-command-ref.html#r-base",
    "href": "A-command-ref.html#r-base",
    "title": "Apéndice A — Comandos de utilidad",
    "section": "",
    "text": "Base R Cheat Sheet.\nR cheat sheet (R. McCulloch).",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Comandos de utilidad</span>"
    ]
  },
  {
    "objectID": "A-command-ref.html#comandos-en-r-studio",
    "href": "A-command-ref.html#comandos-en-r-studio",
    "title": "Apéndice A — Comandos de utilidad",
    "section": "A.2 Comandos en R Studio",
    "text": "A.2 Comandos en R Studio\n\nRStudio IDE Cheatsheet.",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Comandos de utilidad</span>"
    ]
  },
  {
    "objectID": "A-command-ref.html#preparación-de-datos-con-dplyr-y-tidyr",
    "href": "A-command-ref.html#preparación-de-datos-con-dplyr-y-tidyr",
    "title": "Apéndice A — Comandos de utilidad",
    "section": "A.3 Preparación de datos con dplyr y tidyr",
    "text": "A.3 Preparación de datos con dplyr y tidyr\n\nTransformación de datos con dplyr.\nOrganización de datos con tidyr.",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Comandos de utilidad</span>"
    ]
  },
  {
    "objectID": "A-command-ref.html#otras-hojas-de-referencia",
    "href": "A-command-ref.html#otras-hojas-de-referencia",
    "title": "Apéndice A — Comandos de utilidad",
    "section": "A.4 Otras hojas de referencia",
    "text": "A.4 Otras hojas de referencia\n\nCatálogo de Posit Cheatsheets.",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Comandos de utilidad</span>"
    ]
  },
  {
    "objectID": "B-IDEs.html",
    "href": "B-IDEs.html",
    "title": "Apéndice B — Entornos de desarrollo",
    "section": "",
    "text": "B.1 R Studio\nRStudio es un IDE para programación con R y otros lenguajes creado por la empresa Posit PBC.\nEsta es la IDE principal que hemos usado en este tutorial.",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Entornos de desarrollo</span>"
    ]
  },
  {
    "objectID": "B-IDEs.html#vs-code",
    "href": "B-IDEs.html#vs-code",
    "title": "Apéndice B — Entornos de desarrollo",
    "section": "B.2 VS Code",
    "text": "B.2 VS Code\nOtra IDE alternativa para programación con R es Microsoft VS Code.\nUna ventaja de este entorno de programación es que su diseño es muy flexible, basado en extensiones que se pueden activar o desactivar en función del tipo de proyecto, herramientas tecnológicas y el lenguaje de programación utilizado.\n\nR in Visual Studio Code.",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Entornos de desarrollo</span>"
    ]
  },
  {
    "objectID": "C-packages.html",
    "href": "C-packages.html",
    "title": "Apéndice C — Paquetes R destacados",
    "section": "",
    "text": "C.1 tidyverse",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>Paquetes R destacados</span>"
    ]
  },
  {
    "objectID": "C-packages.html#tidyverse",
    "href": "C-packages.html#tidyverse",
    "title": "Apéndice C — Paquetes R destacados",
    "section": "",
    "text": "https://www.tidyverse.org/.",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>Paquetes R destacados</span>"
    ]
  },
  {
    "objectID": "C-packages.html#ggplot2",
    "href": "C-packages.html#ggplot2",
    "title": "Apéndice C — Paquetes R destacados",
    "section": "C.2 ggplot2",
    "text": "C.2 ggplot2\n\nhttps://ggplot2.tidyverse.org/.",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>Paquetes R destacados</span>"
    ]
  },
  {
    "objectID": "C-packages.html#ggally",
    "href": "C-packages.html#ggally",
    "title": "Apéndice C — Paquetes R destacados",
    "section": "C.3 GGally",
    "text": "C.3 GGally\n\nGGally: extensiones de gráficos para ggplot2.",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>Paquetes R destacados</span>"
    ]
  },
  {
    "objectID": "C-packages.html#pipelines",
    "href": "C-packages.html#pipelines",
    "title": "Apéndice C — Paquetes R destacados",
    "section": "C.4 Pipelines",
    "text": "C.4 Pipelines\n\nEl paquete targets ofrece potentes funcionalidades para crear pipelines de procesamiento de datos con R. Si te encuentras con proyectos en los que debes repetir las mismas operaciones de obtención, limpieza y preparación de datos una y otra vez sobre decenas de datasets deberías plantearte definir flujos de trabajo (workflow) para gestionar mejor el progreso de las distintas operaciones.\nA walkthrough to get started with targets.",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>Paquetes R destacados</span>"
    ]
  },
  {
    "objectID": "C-packages.html#data.table",
    "href": "C-packages.html#data.table",
    "title": "Apéndice C — Paquetes R destacados",
    "section": "C.5 data.table",
    "text": "C.5 data.table\nEl paquete data.table (https://rdatatable.gitlab.io/data.table/) presenta una alternativa para el procesamiento de datos distinta a tidyverse. Su sintaxis es menos accesible (sobre todo para programadores sin mucha experiencia), peor a cambio suele ofrecer mucho mayor rendimiento que sus competidores, completando las mismas tareas en menos tiempo (y, con frecuencia, consumiendo menos recursos como memoria RAM).",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>Paquetes R destacados</span>"
    ]
  },
  {
    "objectID": "C-packages.html#pola.rs",
    "href": "C-packages.html#pola.rs",
    "title": "Apéndice C — Paquetes R destacados",
    "section": "C.6 Pola.rs",
    "text": "C.6 Pola.rs\nIncluimos también en este apéndice el nuevo proyecto Polars. Esta es una nueva biblioteca de gestión de DataFrames escrita en el lenguaje de programación Rust con API nativa para este lenguaje y también para Python.\nEl paquete polars en R nos da acceso a las funciones de este nuevo proyecto, que promete mejorar la eficiencia de nuestros proyectos sustancialmente, con paralelización de la ejecución y gestión eficiente de datos en memoria gracias a la integración de Apache Arrow.",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>Paquetes R destacados</span>"
    ]
  },
  {
    "objectID": "C-packages.html#modelos-estadísticos-y-aprendizaje-automático",
    "href": "C-packages.html#modelos-estadísticos-y-aprendizaje-automático",
    "title": "Apéndice C — Paquetes R destacados",
    "section": "C.7 Modelos estadísticos y aprendizaje automático",
    "text": "C.7 Modelos estadísticos y aprendizaje automático\n\nC.7.1 tidymodels\n\nhttps://www.tidymodels.org/.\n\n\n\nC.7.2 mlr\n\nhttps://mlr3.mlr-org.com/.",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>Paquetes R destacados</span>"
    ]
  }
]